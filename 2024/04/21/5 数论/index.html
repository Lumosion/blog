<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>5 数论 | Lumosion's Blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/pwa/favicon.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.8.12"><!-- inject head--><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><!-- katex--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"><!-- Open Graph--><meta name="description" content="数论 高精度 高精度加减乘除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="Lumosion's Blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/pwa/favicon.ico"><link rel="apple-touch-icon" href="/img/pwa/favicon.ico" sizes="180x180"><script>console.log(
    "%c Program: Hexo %c Theme: Solitude %c Version: v1.8.12",
    "border-radius:5px 0 0 5px;padding: 5px 10px;color:white;background:#ff3842;",
    "padding: 5px 10px;color:white;background:#3e9f50;",
    "padding: 5px 10px;color:white;background:#0084ff;",
)
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: undefined,
    runtime: '2023-04-20 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.png'
    },
    copyright: {"limit":50,"author":"作者: Lumosion","link":"链接: ","source":"来源: Lumosion's Blog","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {
        enable: true,
        limit: 200,
        expand: true,
        copy: true,
        syntax: 'highlight.js'
    },
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可"},
    aside: {
        sayhello: {
            morning: '一日之计在于晨',
            noon: '吃饱了才有力气干活',
            afternoon: '集中精力，攻克难关',
            night: '不要太劳累了，早睡更健康',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    post_ai: false,
    right_menu: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body"><!-- universe--><canvas id="universe"></canvas><!-- loading--><!-- console--><div id="console"><div class="close-btn" onclick="sco.hideConsole()"><i class="solitude st-close-fill"></i></div><div class="button-group"><div class="console-btn-item"><span class="darkmode_switchbutton" onclick="sco.switchDarkMode()" title="昼夜切换"><i class="solitude st-moon-clear-fill"></i></span></div><div class="console-btn-item" id="consoleHideAside"><span class="asideSwitch" onclick="sco.switchHideAside()" title="边栏显示控制"><i class="solitude st-side-bar-fill"></i></span></div></div><div class="console-mask" onclick="sco.hideConsole()"></div></div><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">Lumosion</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">5 数论</a></div></div><div id="menus"></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="travellings_button"><a class="site-page" target="_blank" rel="noopener" href="https://lumosion.me" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="travellings_button"><a class="site-page" target="_blank" rel="noopener" href="https://alist.lumosion.me" title=""><i class="solitude st-train-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="/img/default.png" alt="5 数论"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><div class="tag_share"><div class="post-meta__tag-list"></div></div></div></div><h1 class="post-title">5 数论</h1><div id="post-meta"><div class="meta-secondline"></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>数论</h1>
<h2 id="高精度">高精度</h2>
<h3 id="高精度加减乘除">高精度加减乘除</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;   <span class="comment">//最大容量</span></span><br><span class="line">string a, b;    <span class="comment">// 输入字符串</span></span><br><span class="line"><span class="type">int</span> la, lb, lc; <span class="comment">// a,b,c长度</span></span><br><span class="line"><span class="type">int</span> A[N] = &#123;<span class="number">0</span>&#125;, B[N] = &#123;<span class="number">0</span>&#125;, C[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> C[])</span> <span class="comment">// 加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        C[i] += A[i] + B[i];</span><br><span class="line">        C[i + <span class="number">1</span>] += (C[i] / <span class="number">10</span>);</span><br><span class="line">        C[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[])</span> <span class="comment">// 比较大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (la != lb)</span><br><span class="line">        <span class="keyword">return</span> la &gt; lb;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = la - <span class="number">1</span>; ~i; i--)</span><br><span class="line">            <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">                <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 相等返回1,避免结果为-0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> C[])</span> <span class="comment">// 减法，使用了比较大小cmp</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cmp</span>(A, B))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>, <span class="built_in">swap</span>(A, B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; B[i])</span><br><span class="line">            A[i] += <span class="number">10</span>, A[i + <span class="number">1</span>]--; <span class="comment">// 借位</span></span><br><span class="line">        C[i] = A[i] - B[i];         <span class="comment">// 存差</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lc &amp;&amp; C[lc] == <span class="number">0</span>) <span class="comment">// 前导零</span></span><br><span class="line">        lc--;</span><br><span class="line">    lc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> B[], <span class="type">int</span> C[])</span> <span class="comment">// 乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lb; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i + j] += A[i] * B[j];       <span class="comment">// 累加乘积</span></span><br><span class="line">            C[i + j + <span class="number">1</span>] += C[i + j] / <span class="number">10</span>; <span class="comment">// 进位</span></span><br><span class="line">            C[i + j] %= <span class="number">10</span>;                <span class="comment">// 存余</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (lc &amp;&amp; C[lc] == <span class="number">0</span>) <span class="comment">// 前导零</span></span><br><span class="line">        lc--;</span><br><span class="line">    lc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> b, <span class="type">int</span> C[])</span> <span class="comment">// 除法，b为int以内</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> temp = <span class="number">0</span>; <span class="comment">// 临时被除数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = la - <span class="number">1</span>; ~i; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp * <span class="number">10</span> + A[i]; <span class="comment">// 临时被除数</span></span><br><span class="line">        C[i] = temp / b;         <span class="comment">// 存商</span></span><br><span class="line">        temp %= b;               <span class="comment">// 余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (lc &amp;&amp; C[lc] == <span class="number">0</span>) <span class="comment">// 前导零</span></span><br><span class="line">        lc--;</span><br><span class="line">    lc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Input</span><span class="params">(<span class="type">int</span> A[])</span> <span class="comment">// 转化字符串A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++)</span><br><span class="line">        A[la - i - <span class="number">1</span>] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Output</span><span class="params">(<span class="type">int</span> C[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = lc - <span class="number">1</span>; ~i; i--)</span><br><span class="line">        cout &lt;&lt; C[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度取模（秦九韶算法）">高精度取模（秦九韶算法）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string s; <span class="comment">// 输入的大数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mod</span><span class="params">(<span class="type">int</span> p)</span> <span class="comment">// 对p取模</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (res &gt;= p)</span><br><span class="line">            res %= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂">快速幂</h2>
<h3 id="快速幂-快速幂取模">快速幂 快速幂取模</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n)</span> <span class="comment">// 快速幂 a^n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a;</span><br><span class="line">        a = a * a, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickpowmodp</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> p)</span> <span class="comment">// 快速幂取模 a^n%p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % p;</span><br><span class="line">        a = a * a % p, n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵快速幂">矩阵快速幂</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*求矩阵a的k次方*/</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, k;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span> <span class="comment">// 定义矩阵a, res</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125; a, res;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix &amp;x, Matrix &amp;y) <span class="comment">// 矩阵乘法</span></span><br><span class="line">&#123;</span><br><span class="line">    Matrix t; <span class="comment">// 临时矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="comment">// x的列数，y的行数必须相等，内层效率高</span></span><br><span class="line">                t.c[i][j] = (t.c[i][j] + x.c[i][k] * y.c[k][j]) % mod;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> k)</span> <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        res.c[i][i] = <span class="number">1</span>; <span class="comment">// 单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a;</span><br><span class="line">        a = a * a, k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大公约数-欧几里得算法（GCD）">最大公约数-欧几里得算法（GCD）</h2>
<p>$$<br>
当a&gt;b,则\gcd(a,b)=\gcd(b,a\bmod b)<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="comment">// 确保a大</span></span><br><span class="line">        <span class="built_in">swap</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="质数">质数</h2>
<h3 id="判断素数-试除法">判断素数-试除法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分解质因数">分解质因数</h3>
<p>$$<br>
n=p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\dots p_s^{\alpha_s},p_1&lt;p_2&lt;p<br>
_3&lt;\dots&lt;p_S<br>
$$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500005</span>;</span><br><span class="line"><span class="type">int</span> a[N]; <span class="comment">// 代表含质因子i的个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">decompose</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            a[i]++, x /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">        a[x]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛法">筛法</h2>
<h3 id="埃氏筛法">埃氏筛法</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000010</span>; <span class="comment">// 最大</span></span><br><span class="line"><span class="type">int</span> vis[N] = &#123;<span class="number">0</span>&#125;;        <span class="comment">// 划掉合数</span></span><br><span class="line"><span class="type">int</span> prim[N] = &#123;<span class="number">0</span>&#125;;       <span class="comment">// 记录质数</span></span><br><span class="line"><span class="type">int</span> cnt;                 <span class="comment">// 质数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 埃氏筛法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prim[++cnt] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">                vis[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛">线性筛</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意空间，prim有效从下标1开始</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000010</span>; <span class="comment">// 最大</span></span><br><span class="line"><span class="type">int</span> vis[N] = &#123;<span class="number">0</span>&#125;;        <span class="comment">// 划掉合数</span></span><br><span class="line"><span class="type">int</span> prim[N] = &#123;<span class="number">0</span>&#125;;       <span class="comment">// 记录质数</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;             <span class="comment">// 质数个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prim</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] == <span class="number">0</span>)</span><br><span class="line">            prim[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; <span class="number">1ll</span> * i * prim[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prim[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数">欧拉函数</h3>
<p>**欧拉函数 **$\varphi(n)$ 指小于 $n$ ，并且与 $n$ 互质的数的个数。</p>
<p>$\varphi ( n ) = \sum\limits _ { i = 1 } ^ { n } [ \gcd ( i , n ) = 1 ]$</p>
<p>性质： $\sum\limits _ { d | n } \varphi ( d ) = n$</p>
<ul>
<li>当 $n$ 为质数，$\varphi (n)=p-1$</li>
<li>当 $p$ 为质数，$\varphi (p^k)=(p-1)*p^{k-1}$</li>
<li>当 $n$ 为合数，$\varphi (n)=s*\prod \limits_{i=1}^s{\frac{p_i-1}{pi}}$
<ul>
<li>$n=p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\dots p_s^{\alpha_s},p_1&lt;p_2&lt;p<br>
_3&lt;\dots&lt;p_S$</li>
</ul>
</li>
</ul>
<p>求单个欧拉函数，代码使用<strong>试除法</strong>，多个使用<strong>线性筛</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求单个欧拉函数，试除法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_phi</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="约数">约数</h3>
<p><strong>约数个数定理</strong>：若 $n=\prod \limits_{i=1}^s{p_i^{\alpha_i}}$ ，约数个数 $d(n)=\prod \limits_{i=1}^s{(\alpha_i+1)}$</p>
<p>结论： $d(ij)=\sum\limits_{x|i} \sum\limits_{y|j}[\gcd(x,y)=1]$  （使用<strong>和式的变换</strong>、<strong>莫比乌斯反演</strong>）</p>
<p><strong>约数分解规则</strong></p>
<ol>
<li>总是先从 $i$ 中取质因子（唯一性）</li>
<li>如果 $i, j$ 中质因子雷同，则把 $i$ 中的该质因子变成 $1$ （互质性）</li>
</ol>
<p><strong>约数和定理</strong>：若 $n=\prod \limits_{i=1}^s{p_i^{\alpha_i}}$ ，约数和 $f(n)=\prod \limits_{i=1}^s{\sum_{j=0}\limits^{\alpha_{i}}{p_i^j}}$</p>
<h3 id="莫比乌斯函数">莫比乌斯函数</h3>
<p><strong>莫比乌斯函数</strong>：$\begin{align*}\begin{split}\mu(n)= \left {\begin{array}{lr}1,&amp; n=1\0,&amp; n含相同质因子\(-1)^s,&amp; s为n的不同质因子的个数\end{array}\right.\end{split}\end{align*}$</p>
<p>性质： $\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]$</p>
<h2 id="同余式">同余式</h2>
<p>若 $a,b$ 模 $m$ 余数相同，则 $a,b$ 模 $m$ 同余。</p>
<p>即 $ a\equiv b(\bmod m)$</p>
<h3 id="费马小定理">费马小定理</h3>
<p>若 $p$ 为质数，且 $a,p$ 互质，则 $a^{p-1}\equiv (\bmod p)$</p>
<h3 id="乘法逆元（费马小定理）">乘法逆元（费马小定理）</h3>
<p>若 $a,p$ 互质，且满足同余方程 $ax\equiv 1(\bmod p)$，则 $x$ 为 $a$ 模 $p$ 的乘法逆元，记作 $a^{-1}$；</p>
<p><strong>若 $p$ 为质数</strong>，根据<strong>费马小定理</strong>可知 $a^{p-2}\times a \equiv (\bmod p)$， $x=a^{p-2}(\bmod p)$；</p>
<p>代码使用<strong>快速幂取模</strong>求$a^{p-2}(\bmod p)$。</p>
<h3 id="剩余系">剩余系</h3>
<p><strong>剩余系（同余系）</strong>：给定一个正整数 $n$ ，把所有整数<strong>根据模 $n$ 的余数</strong> $r∈[0,n -1]$ 分为 $n$ 类，每一类表示为 $C_r = nx +r$ 的形式，这类数所构成的一个集合称为模 $n$ 的剩余类。</p>
<p><strong>完全剩余系（完系）</strong>：给定一个正整数 $n$ ，有 $n$ 个不同的模 $n$ 的剩余类，从这 $n$ 个不同的剩余类中<strong>各取出一个元素</strong>，总共 $n$ 个数,将这些数构成一个新的集合，则称这个集合为模 $n$ 的完全剩余系。</p>
<p><strong>简化剩余系（缩系）</strong>：给定一个正整数 $n$ ，有 $\varphi (n)$ 个不同的模 $n$ 的<strong>余数 $r$ 与 $n$ 互质</strong>的剩余类，从这 $\varphi(n)$ 个剩余类中各取出一个元素，总共 $\varphi(n)$ 个数,将这些数构成一个新的集合，则称这个集合为模 $n$ 的简化剩余系。</p>
<h3 id="欧拉定理">欧拉定理</h3>
<p>若 $\gcd(a,m)=1$，则 $a^{\varphi(m)}\equiv 1(\bmod m)$；</p>
<p>当 $m$ 为质数时，由于 $\varphi (m)=m-1$ ，带入欧拉定理可得<strong>费马小定理</strong> $a^{m-1}\equiv m$ ；</p>
<h3 id="扩展欧拉定理">扩展欧拉定理</h3>
<ul>
<li>当 $b$ 小时，直接快速幂；</li>
<li>当 $b$ 大时，先降，再快速幂；</li>
</ul>
<p>$a^b=\begin{align*}\begin{split} \left {\begin{array}{lr}a^b,&amp; b&lt;\varphi(m)\a^{b \ \bmod \ \varphi(m)+\varphi(m)},&amp; b\ge\varphi(m)\end{array}\right.\end{split}\end{align*} ,(\bmod m)$</p>
<p>代码：<strong>欧拉函数</strong>+<strong>高精度取模</strong>+<strong>快速幂取模</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_phi</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 求单个欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">depow</span><span class="params">(<span class="type">int</span> phi, string bs)</span> <span class="comment">// 高精度取模降幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>, flag = <span class="number">0</span>; <span class="comment">// b为返回值，flag为标记是否需要最后+phi(x)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; bs[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b = b * <span class="number">10</span> + bs[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b &gt;= phi)</span><br><span class="line">            flag = <span class="number">1</span>, b %= phi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        b += phi;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(ll a, <span class="type">int</span> b, <span class="type">int</span> p)</span> <span class="comment">// 快速幂取模</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Euler</span><span class="params">(<span class="type">int</span> a, string bs, <span class="type">int</span> p)</span> <span class="comment">// 欧拉定理,求a^b % p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> phi = <span class="built_in">get_phi</span>(p);   <span class="comment">// 先求phi(p)</span></span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">depow</span>(phi, bs); <span class="comment">// 高精度取模降幂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, b, p);   <span class="comment">// 快速幂取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="威尔逊定理">威尔逊定理</h3>
<p>$(p-1)!\equiv -1(\bmod p) \Longleftrightarrow p$ 为质数</p>
<ul>
<li>推论
<ol>
<li>若 $p$ 是质数，则 $(p-1) !+1 \equiv 0(\bmod p)$</li>
<li>若 $p$ 是大于 $4$ 的合数，则 $(p-1) ! \equiv 0(\bmod p)$</li>
<li>$p=1$，$(1-1)! \equiv 0(\bmod1)$；</li>
<li>$p=4$，$(4-1)! \equiv 2(\bmod 4)$；</li>
</ol>
</li>
</ul>
<h3 id="裴蜀定理">裴蜀定理</h3>
<p><strong>裴蜀定理</strong>：一定存在整数 $x,y$ ，满足 $ax+by=gcd(a,b)$ ；</p>
<p><strong>推广</strong>：$\sum <em>{i=1}^{n}A</em>{i}X_{i}=gcd(A_{1},A_{2}, \cdots ,A_{n})$</p>
<h3 id="扩展欧几里得定理">扩展欧几里得定理</h3>
<p>$Q$ ：求 $ax+by=gcd(a,b)$ 一组整数解</p>
<p>当 $b=0$ 时，$ax+by=a$，则 $x=1$，$y=0$</p>
<p>当 $b\neq 0$时，由<strong>裴蜀定理</strong></p>
<p>​					 $gcd(a,b)=ax+by$</p>
<p>​					$gcd(b,a%b)=bx_1+(a%b)y_1=ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1)$</p>
<p>​					<strong>递推公式</strong>：$x_n=y_{n-1},y_n=x_{n-1}-\lfloor\frac{a}{b}\rfloor y_{n-1}$</p>
<p>​					求得<strong>特解 $x_0,y_0$</strong>；</p>
<p>​					<strong>通解</strong>：$\begin{align*}\begin{split} \left {\begin{array}{lr}x=x_0+\frac{b}{gcd(a,b)}*k\y=y_0-\frac{a}{gcd(a,b)}<em>k\end{array}\right.\end{split}\end{align</em>} (考虑ax+by=0构造)$</p>
<p>求<strong>最靠近原点</strong>的一组<strong>特解</strong> $x_2,y_2$</p>
<p>则需满足条件 $x_2+y2$</p>
<p><em>求特解代码</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> <span class="comment">// a&gt;=b 注意数值范围</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a; <span class="comment">// 最大公约数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, d;</span><br><span class="line">    d = <span class="built_in">exgcd</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1;</span><br><span class="line">    y = x1 - a / b * y1;</span><br><span class="line">    <span class="keyword">return</span> d; <span class="comment">// 最大公约数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不定方程">不定方程</h3>
<p>$Q$ ：求 $ax+by=c$ 一组整数解</p>
<p>若 $gcd(a,b)\nmid c$ ，则无整数解；</p>
<p>若 $gcd(a,b)\mid c$，则先求 $ax+by=gcd(a,b)$ 整数解，然后乘以相应倍数 $\frac{c}{gcd(a,b)}$；</p>
<p>转化为<strong>扩展欧几里得定理</strong></p>
<h3 id="同余方程">同余方程</h3>
<p>$ax \equiv b(\bmod m)$</p>
<p>$ax=m(-y)+b$</p>
<p>$ax+my=b$</p>
<p>转化为<strong>不定方程</strong></p>
<h3 id="乘法逆元（通用）">乘法逆元（通用）</h3>
<p>若 $a,m$ 互质，求 $ax \equiv 1(\bmod m)$ 的解 $x$ ；</p>
<p>转化为<strong>不定方程</strong>即 $ax+my=1$</p>
<p>使用<strong>扩展欧几里得算法</strong>的到 $ax+my=gcd(a,m)$ 解 $x$ ；</p>
<p>最终答案：$(x % m+m)% m$ ，“模加模”保证得到<strong>最小正整数</strong>；</p>
<h3 id="中国剩余定理（CRT）">中国剩余定理（CRT）</h3>
<p>求解线性同余方程</p>
<p>$\left{ \begin{matrix} x \equiv r_{1}(\bmod m_{1})\ x \equiv r_{2}(\bmod m_{2})\ \vdots\ x \equiv r_{n}(\bmod m_{n})\ \end{matrix} \right.$</p>
<p>其中模数 $m_1, m_2,… , m_n$为 <strong>两两互质</strong>的整数,求 $x$ 的最小非负整数解。</p>
<ol>
<li>计算所有模数的积 $M$</li>
<li>计算第 $i$ 个方程的 $c_{i}=\frac{M}{m_{i}}$</li>
<li>计算 $c_{i}$ 在模 ${m}<em>{i}$ 意义下的逆元 $c</em>{i}^{-1}$</li>
<li>$x=\sum_{i=1}^{n} r_{i} c_{i} c_{i}^{-1}(\bmod M)$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n; <span class="comment">// 式子总数</span></span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> <span class="comment">// 扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d, x1, y1;</span><br><span class="line">    d = <span class="built_in">exgcd</span>(b, a % b, x1, y1);</span><br><span class="line">    x = y1, y = x1 - a / b * y1;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(ll m[], ll r[])</span> <span class="comment">// 中国剩余定理 x=r(mod m) 从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll M = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        M *= m[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll c = M / m[i];</span><br><span class="line">        <span class="built_in">exgcd</span>(c, m[i], x, y);</span><br><span class="line">        ans = (ans + r[i] * c * x % M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M; <span class="comment">// 最小非负整数解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展中国剩余定理（EXCRT）">扩展中国剩余定理（EXCRT）</h3>
<p>求解线性同余方程</p>
<p>$\left{ \begin{matrix} x \equiv r_{1}(\bmod m_{1})\ x \equiv r_{2}(\bmod m_{2})\ \vdots\ x \equiv r_{n}(\bmod m_{n})\ \end{matrix} \right.$</p>
<p>其中模数 $m_1, m_2,\dots, m_n$ <strong>不一定</strong> 为 <strong>两两互质</strong>的整数,求 $x$ 的最小非负整数解。</p>
<p>前两个方程： $x \equiv r_{1}\left(\bmod m_{1}\right), x \equiv r_{2}\left(\bmod m_{2}\right)$</p>
<p>转化为<strong>不定方程</strong>： $x = m_{1} p+r_{1} = m_{2} q+r_{2}$</p>
<p>则 $m_{1} p-m_{2} q = r_{2}-r_{1}$</p>
<p>由<strong>裴蜀定理</strong>，当 $\operatorname{gcd}\left(m_{1}, m_{2}\right) \nmid\left(r_{2}-r_{1}\right)$ 时，无解</p>
<p>​					   当 $\operatorname{gcd}\left(m_{1}, m_{2}\right) \mid\left(r_{2}-r_{1}\right)$ 时，有解</p>
<p>由<strong>扩欧算法</strong>，得特解 $p = p * \frac{r_{2}-r_{1}}{g c d}, q = q * \frac{r_{2}-r_{1}}{g c d}$</p>
<p>其<strong>通解</strong>  $P = p+\frac{m_{2}}{g c d} * k, Q = q-\frac{m_{1}}{g c d} * k$</p>
<p>所以  $x = m_{1} P+r_{1} = \frac{m_{1} m_{2}}{g c d} * k+m_{1} p+r_{1}$</p>
<p>前两个方程等价合并为一个方程 $x \equiv r(\bmod m)$</p>
<p>其中<strong style="background:rgb(225,255,255);"> $r=m_1p+r_1，m=lcm⁡(m_1,m_2) $</strong></p>
<p>所以 $n$ 个同余方程只要合并 $n-1$ 次, 即可求解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll n; <span class="comment">// 式子总数</span></span><br><span class="line"><span class="function">ll <span class="title">EXCRT</span><span class="params">(ll m[], ll r[])</span> <span class="comment">// 扩展中国剩余定理 x=r(mod m) 从0开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll m1, m2, r1, r2, p, q, d;</span><br><span class="line">    m1 = m[<span class="number">0</span>];</span><br><span class="line">    r1 = r[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m2 = m[i];</span><br><span class="line">        r2 = r[i];</span><br><span class="line">        d = <span class="built_in">exgcd</span>(m1, m2, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((r2 - r1) % d) <span class="comment">// 无解</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        p = p * (r2 - r1) / d;                  <span class="comment">// 特解</span></span><br><span class="line">        p = (p % (m2 / d) + m2 / d) % (m2 / d); <span class="comment">// 保证正数</span></span><br><span class="line">        r1 = m1 * p + r1;</span><br><span class="line">        m1 = m1 * m2 / d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (r1 % m1 + m1) % m1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BSGS算法">BSGS算法</h3>
<p>给定整数 $a,b,p$，其中 $a,p$ 互质，</p>
<p>求满足 $a^x \equiv  b(\bmod p)$ 最小非负整数 $x$</p>
<h3 id="扩展BSGS算法">扩展BSGS算法</h3>
<h2 id="线性方程">线性方程</h2>
<h3 id="高斯消元法">高斯消元法</h3>
<p><strong>矩阵的初等行变换</strong></p>
<ol>
<li>交<strong>换</strong>两行；</li>
<li>把某一行乘一个**非 $0$ **的数；</li>
<li>把某行的若干倍<strong>加</strong>到另一行上去；</li>
</ol>
<p>先把系数矩阵消成<strong>上三角矩阵</strong>，再从下到上<strong>回代</strong>求解</p>
<p>$\left[\begin{array}{ccccccc}<br>
1 &amp; \mathrm{a}<em>{12}^{\prime} &amp; a</em>{13}^{\prime} &amp; a_{14}^{\prime} &amp; \cdots &amp; a_{1 n}^{\prime} &amp; b_{1}^{\prime} \<br>
&amp; 1 &amp; a_{23}^{\prime} &amp; a_{24}^{\prime} &amp; \cdots &amp; a_{2 n}^{\prime} &amp; b_{2}^{\prime} \<br>
&amp; &amp; 1 &amp; a_{34}^{\prime} &amp; \cdots &amp; a_{3 n}^{\prime} &amp; b_{3}^{\prime} \<br>
&amp; &amp; &amp; \ddots &amp;\ddots &amp; \vdots &amp; \vdots \<br>
&amp; &amp; &amp; &amp;1 &amp; a_{n-1, n}^{\prime} &amp; b_{n-1}^{\prime} \<br>
&amp; &amp; &amp; &amp; &amp; 1 &amp; \mathrm{~b}_{n}^{\prime}<br>
\end{array}\right]$</p>
<ol>
<li>枚举<strong>主元</strong>, 找到主元下面系数不是 $0$ 的一行；</li>
<li>用<strong>变换1</strong>, 把这一行与主元行交换；</li>
<li>用<strong>变换2</strong>, 把主元系数变成 $1$ ；</li>
<li>用<strong>变换3</strong>, 把主元下面的系数变成 $0$ 。</li>
</ol>
<h2 id="组合数">组合数</h2>
<h3 id="递推法（杨辉三角）">递推法（杨辉三角）</h3>
<p><em><strong>时间复杂度： $O(n^2)$</strong></em></p>
<ul>
<li>
<p>$C _ { n } ^ { 0 } = C _ { n } ^ { n } = 1$</p>
</li>
<li>
<p>$C _ { n } ^ { m } = C _ { n } ^ { n - m }$</p>
</li>
<li>
<p><strong style="color:red;">$C _ { n } ^ { m } = C _ { n - 1 } ^ { m } + C _ { n - 1 } ^ { m - 1 }$ </strong></p>
</li>
</ul>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20230729155557911.png" alt="image-20230729155557911" style="zoom:50%;" />
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用C[n][m]即可</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> C[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 组合数模MOD</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 第一列全为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂求组合数">快速幂求组合数</h3>
<p><em><strong>时间复杂度： $O(n\log p)$</strong></em></p>
<ul>
<li>$C _ { n } ^ { m } = \frac { n ! } { ( n - m ) ! m ! }$</li>
</ul>
<p>开两个数组分别存模意义下的<strong>阶乘</strong>和<strong>阶乘的逆元</strong></p>
<p>用 $f[x]$ 存 $x!(\bmod p)$ 的值</p>
<p>用 $g[x]$ 存 $(x!)^{-1}(\bmod p)$ 的值，使用<strong>费马小定理</strong>和<strong>快速幂</strong>求逆元</p>
<p>费马小定理： $a \cdot ( a ^ { p - 2 } ) = 1 ( \bmod p )$</p>
<p>$g[x]$ 递推公式： $\frac { 1 } { i! } ( \bmod p ) = \frac { 1 } { i } \times \frac { 1 } { ( i - 1 ) ! } ( \bmod p ) = i^{p-2} * g [ i - 1 ] (\bmod p)$</p>
<p>查询时使用： $C _ { n } ^ { m } ( \bmod p ) = f [ n ] * g [ n - m ] * g [ m ] ( \bmod p )$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">ll f[N];             <span class="comment">// f存 i!%MOD的值</span></span><br><span class="line">ll g[N];             <span class="comment">// g存 i!%MOD的逆元 值</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="type">int</span> b)</span> <span class="comment">// 快速幂取模</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % MOD;</span><br><span class="line">        a = a * a % MOD;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 0！逆元和自己都是1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line">        g[i] = g[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, MOD - <span class="number">2</span>) % MOD; <span class="comment">// 递推 （之前的逆元）乘以（1/i的逆元）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(ll n, ll m)</span> <span class="comment">// 获得C(n,m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[n] * g[m] % MOD * g[n - m] % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卢卡斯定理（Lucas）">卢卡斯定理（Lucas）</h3>
<p><em><strong>时间复杂度： $O(p\log p + \log_p n)$</strong></em></p>
<p>$C _ { n } ^ { m } = C _ { n / p } ^ { m/p } C _{n\bmod p} ^{m \bmod p} ( \bmod p )$ ，其中 $p$ 为质数</p>
<p>$n\bmod p$和 $n\bmod p$ 一定是小于 $p$ 的数，可以直接求解， $ C _ { n / p } ^ { m/p }$ 可以继续用 <strong>Lucas定理</strong> 求解。</p>
<p>边界条件：当 $m=0$ 时，返回 $1$ 。</p>
<p>证明：</p>
<ul>
<li><strong>引理1</strong>： $C _ { p } ^ { x } = 0 ( \bmod p ) , 0 \lt x \lt p$
<ul>
<li>$C _ { p } ^ { x } = \frac { p ! } { x ! ( p - x ) ! } = \frac { p ( p - 1 ) ! } { x ( x - 1 ) ! ( p - x ) ! } = \frac { p } { x } C _ { p - 1 } ^ { x - 1 }$</li>
<li>$C _ { p } ^ { x } = p \cdot i n v ( x )  {  C _ { p - 1 } ^ { x - 1 } } = 0 ( \bmod p )$</li>
</ul>
</li>
<li><strong>引理2</strong>： $( 1 + x ) ^ { p } = 1 + x ^ { p } ( \bmod p )$
<ul>
<li>二项式定理知： $( 1 + x ) ^ { p } = \sum _ { i = 0 } ^ { p } C _ { p } ^ { i } x ^ { i }$</li>
<li>由上一证明知，只剩 $i=0,p$ 两项，得证。</li>
</ul>
</li>
<li>证明：</li>
</ul>
<p>$( 1 + x ) ^ { n } \equiv \sum _ { i = 0 } ^ { n } C _ { n } ^ { i } x ^ { i } ( m o d p ) – ( 1 )$</p>
<p>$\begin{aligned}<br>
(1+x)^{n} &amp; \equiv(1+x)^{a p+b} \<br>
&amp; \equiv\left((1+x)^{p}\right)^{a} \cdot(1+x)^{b} \<br>
&amp; \equiv\left(1+x^{p}\right)^{a} \cdot(1+x)^{b} \<br>
&amp; \equiv \sum_{i=0}^{a} C_{a}^{i} x^{i p} \cdot \sum_{j=0}^{b} C_{b}^{j} x^{j}(\bmod p)–(2)<br>
\end{aligned}$</p>
<p>$(1)$ 中 $x ^ { m }$ 的系数为 $C_{n}^{m}$</p>
<p>$(2)$ 中 $x^m =x^{cp} \cdot x^d$ 的系数为 $C _ { a } ^ { c } C _ { b } ^ { d }$</p>
<p>则： $C _ { n } ^ { m } = C _ { a } ^ { c } C _ { b } ^ { d } ( \bmod p )$</p>
<p>即： $C _ { n } ^ { m } = C _ { n / p } ^ { m/p } C _{n\bmod p} ^{m \bmod p} ( \bmod p )$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">ll f[N], g[N];</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            res = res * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] * i % p;</span><br><span class="line">        g[i] = g[i - <span class="number">1</span>] * <span class="built_in">qpow</span>(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小数组合数</span></span><br><span class="line"><span class="function">ll <span class="title">getC</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[n] * g[m] * g[n - m] % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卢卡斯定理 Lucas</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(ll n, ll m, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lucas</span>(n / p, m / p, p) * <span class="built_in">getC</span>(n % p, m % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性筛-高精度求组合数（单个）">线性筛+高精度求组合数（单个）</h3>
<p><em><strong>时间复杂度： $O(mnN)$</strong></em>  $N$ 为数字位数</p>
<p>$n!$ 中 $p$ 的个数 $s = \frac { n } { p } + \frac { n } { p ^ { 2 } } + \frac { n } { p ^ { 3 } } + \cdots$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N为组合数n的最大大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> prim[N], vis[N], cnt; <span class="comment">// prim[]存储素数，vis[]存储访问情况，cnt代表素数个数</span></span><br><span class="line"><span class="comment">// 线性筛 筛素数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_prim</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            prim[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i * prim[j] &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prim[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prim[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n!中p的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">        s += n / p, n /= p;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C中p的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getps</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(n, p) - <span class="built_in">get</span>(m, p) - <span class="built_in">get</span>(n - m, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高精度乘法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> C[], <span class="type">int</span> p, <span class="type">int</span> &amp;len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i] * p;</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        C[len++] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Cnm的结果存储在C[]中，返回C的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getC</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> C[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/////////////////////////////</span></span><br><span class="line">    <span class="comment">// 全局只需要进行一次最大的即可</span></span><br><span class="line">    <span class="built_in">get_prim</span>(n);</span><br><span class="line">    <span class="comment">// 全局只需要进行一次最大的即可</span></span><br><span class="line">    <span class="comment">////////////////////////////</span></span><br><span class="line">    <span class="comment">// 外部定义</span></span><br><span class="line">    <span class="comment">// int C[N];</span></span><br><span class="line">    <span class="comment">////////////////////////////</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    C[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p = prim[i];</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">getps</span>(n, m, p);</span><br><span class="line">        <span class="keyword">while</span> (s--)</span><br><span class="line">            <span class="built_in">mul</span>(C, p, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="comment">//  for (int i = len - 1; i &gt;= 0; i--)</span></span><br><span class="line">    <span class="comment">//      cout&lt;&lt; C[i];</span></span><br><span class="line">    <span class="comment">// 最后结果存储在C[]中</span></span><br><span class="line">    <span class="keyword">return</span> len; <span class="comment">// 返回C的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="递推法-高精度（单个）">递推法+高精度（单个）</h3>
<p>时间不推荐，推荐 前面那个 <strong>线性筛+高精度求组合数（单个）</strong></p>
<p><em><strong>时间复杂度： $O(mnN)$</strong></em>  $N$ 为数字位数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合数的最大数位</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="comment">// 第一位表示最大的n，第二位表示最大的m，第三位表示数位（注意倒叙）</span></span><br><span class="line"><span class="type">int</span> C[<span class="number">500</span>][<span class="number">100</span>][N];</span><br><span class="line"><span class="comment">// 高精度加法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c[], <span class="type">int</span> a[], <span class="type">int</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += a[i] + b[i];</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求组合数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getC</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i &amp;&amp; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                C[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">add</span>(C[i][j], C[i - <span class="number">1</span>][j], C[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 使用方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = N - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 删除前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C[n][m][i] == <span class="number">0</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[n][m][i--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组合数命名空间（快速幂）">组合数命名空间（快速幂）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> i64;</span><br><span class="line"><span class="type">const</span> i64 mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">i64 <span class="title">fpow</span><span class="params">(i64 x, i64 r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i64 result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &amp; <span class="number">1</span>)</span><br><span class="line">            result = result * x % mod;</span><br><span class="line">        r &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> binom</span><br><span class="line">&#123;</span><br><span class="line">    i64 fac[N], ifac[N];</span><br><span class="line">    <span class="type">int</span> __ = []</span><br><span class="line">    &#123;</span><br><span class="line">        fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">5</span>; i++)</span><br><span class="line">            fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        ifac[N - <span class="number">5</span>] = <span class="built_in">fpow</span>(fac[N - <span class="number">5</span>], mod - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">5</span>; i; i--)</span><br><span class="line">            ifac[i - <span class="number">1</span>] = ifac[i] * i % mod;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> i64 <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> i64 <span class="title">A</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m || m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> fac[n] * ifac[n - m] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> binom;</span><br></pre></td></tr></table></figure>
<h3 id="隔板法">隔板法</h3>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1771">洛谷 P1771 方程的解</a></p>
<ol>
<li>求线性不定方程的整数解的组数</li>
<li>求相同元素分组的方案数</li>
</ol>
<ul>
<li><strong>现有 $n$ 个完全相同的元素，将其分为 $k$ 组，保证每组至少有 $1$ 个元素，一共有多少种分法？</strong></li>
</ul>
<p>​	把 $n$ 个相同的球排成一行，有 $n-1$ 个空；</p>
<p>​	拿 $k-1$ 块板子插入到 $n-1$ 个空里，把球分成 $k$ 组；</p>
<p>​	即在 $n-1$ 个空里选择 $k-1$ 个空插板子，所以答案就是<strong style="color:red;"> $C_{n-1}^{k-1}$ </strong>；</p>
<p><strong>？1</strong> <strong>正整数和的组数</strong> 若 $x _ { i } \geq 1$ ，求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } = n$ 的整数解的组数。 <strong style="color:red;"> $C_{n-1}^{k-1}$ </strong></p>
<p><strong>？2</strong> <strong>非负整数和的组数</strong> 若 $x _ { i } \geq 0$ ，求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } = n$ 的整数解的组数。 <strong style="color:red;">$C _ { n + k - 1 } ^ { k - 1 }$</strong></p>
<p>​		令 $y_i=x_i+1$ ，则 $y _ { i } \geq 1$ ；</p>
<p>​		则 转化为 $y _ { 1 } + y _ { 2 } + \cdots + y _ { k } = n + k = m$</p>
<p>​		转化为 <strong>？1</strong> ，答案为 $C _ { m - 1 } ^ { k - 1 } = C _ { n + k - 1 } ^ { k - 1 }$</p>
<p><strong>？3</strong> <strong>不同下界整数和的组数</strong> 求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } = n$ 的整数解的组数，其中 $x _ { i } \geq a _ { i } \geq 0 $ ，$\sum a _ { i } \leq n$  <strong style="color:red;">$C _ { n - \sum a _ { i } + k -1} ^ { k - 1 }$</strong></p>
<p>​		令 $y _ { i } = x _ { i } - a _ { i } + 1$ ，则 $y _ { i } \geq 1$ ；</p>
<p>​		则 转化为 $y _ { 1 } + y _ { 2 } + \cdots + y _ { k } = n - \sum a _ { i } + k = m$</p>
<p>​		转化为 <strong>？1</strong> ，答案为 $C _ { m - 1 } ^ { k - 1 } = C _ { n - \sum a _ { i } + k -1} ^ { k - 1 } $</p>
<h3 id="卡特兰数（Catalan）">卡特兰数（Catalan）</h3>
<p>两种操作，一种操作数不能超过另外一种操作数，或者两种操作不能有交集，这些操作的合法方案数，通常是卡特兰数。</p>
<p>以走网格为例，从格点 $(0,0)$ 走到格点 $(n,n)$ ，只能向右或向上走，并且不能越过对角线的路径的条数，就是卡特兰数，记为 $H_n$ 。</p>
<ul>
<li>组合数： $H _ { n } = C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 }$</li>
<li>组合数： $H _ { n } = \frac { 1 } { n + 1 } C _ { 2 n } ^ { n }$</li>
<li>递推计算： $H _ { n } = \frac { 4 n - 2 } { n + 1 } H _ { n - 1 }$</li>
</ul>
<center><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308072106416.png" alt="image-20230802160529386" style="zoom:50%;" /><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308021605987.png" alt="image-20230802160545936" style="zoom: 50%;" /></center>
<p>先求<strong>路径总数</strong>：在 $2n$ 次移动中选 $n$ 次向右移动，即 $C_{2n}^{m}$ ，再求非法路径，即越过对角线的路径；</p>
<p>再求<strong>非法路径</strong>，即越过对角线的路径：</p>
<p>把 $y=x+1$ 这条线画出来，碰到即说明是一条非法路径。所有的非法路径与这条线有至少一个交点，把第一个交点设为 $(a,a+1)$ ；</p>
<p>把 $(a,a+1)$ 之后的路径全部按照 $y=x+1$ 这条线对称过去，这样，最后的终点就会变成 <strong>$(n-1,n+1)$</strong> ；</p>
<p>所有非法路径对称后都<strong>唯一</strong>对应着一条到 $(n-1,n+1)$ 的路径，所以非法路径数就是 $C _ { 2 n } ^ { n - 1 }$ ,合法路径数就是 $C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 }$ 。</p>
<p>$\begin{align}H_{n}&amp;=C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 } \&amp;= \frac { ( 2 n ) ! } { n ! n ! } - \frac { ( 2 n ) ! } { ( n + 1 ) ! ( n - 1 ) ! }\&amp;= \frac { ( 2 n ) ! } { n ! ( n - 1 ) ! } ( \frac { 1 } { n } - \frac { 1 } { n + 1 } ) \&amp;= \frac { ( 2 n ) ! } { n ! n ! ( n + 1 ) } \&amp;= \frac { 1 } { n + 1 } C _ { 2 n } ^ { n }\end{align}$</p>
<p><em><strong>Catalan应用</strong></em></p>
<ol>
<li>
<p>一个有 $n$ 个 $0$ 和 $n$ 个 $1$ 组成的字串，且所有的前缀字串皆满足 $1$ 的个数不超过 $0$ 的个数。这样的字串个数有多少？</p>
</li>
<li>
<p>包含 $n$ 组括号的合法运算式的个数有多少？</p>
</li>
<li>
<p>一个栈的进栈序列为 $1,2,3，…，n$ ，有多少个不同的出栈序列？</p>
</li>
<li>
<p>$n$ 个结点可构造多少个不同的二叉树？</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3402.html">n个结点构造多少种树</a></p>
<ol start="5">
<li>
<p>在圆上选择 $2$ 个点，将这些点成对连接起来使得所得到的 $n$ 条弦不相交的方法数？</p>
</li>
<li>
<p>通过连结顶点而将 $n+2$ 边的凸多边形分成n个三角形的方法数？</p>
</li>
</ol>
<h2 id="容斥原理">容斥原理</h2>
<h3 id="集合的并">集合的并</h3>
<p>设 $U$ 中元素有 $n$ 种不同的属性，第 $i$ 种属性称为 $P$ ，拥有属性 $P$ 的元素构成集合 $S$ ，那么$\begin{aligned}<br>
\left|\bigcup_{i=1}^{n} S_{i}\right|= &amp; \sum_{i}\left|S_{i}\right|-\sum_{i&lt;j}\left|S_{i} \cap S_{j}\right|+\sum_{i&lt;j&lt;k}\left|S_{i} \cap S_{j} \cap S_{k}\right|-\cdots<br>
+(-1)^{m-1} \sum_{a_i&lt;a_{i+1}}\left|\bigcap_{i=1}^{m} S_{a_i}\right|+\cdots+(-1)^{n-1}\left|S_{1} \cap \cdots \cap S_{n}\right|<br>
\end{aligned}$</p>
<p>即：$\begin{aligned}<br>
\left|\bigcup_{i=1}^{n} S_{i}\right|= \sum^n_{m-1} (-1)^{m-1} \sum_{a_i&lt;a_{i+1}}\left| \bigcap_{i=1}^{m} S_{a_i}\right|<br>
\end{aligned}$</p>
<p><strong style="color:red;">集合的并等于集合的交的交错和（奇正偶负）</strong></p>
<p>使用的<strong>二进制位</strong>来表示每个集合**选（1）<strong>与</strong>不选（0）**的状态</p>
<p><strong>Q</strong>：给定一个整数 $n$ 和 $m$ 个不同的质数 $p _ { 1 } , p _ { 2 } , \cdots , p _ { m }$ ，求 $1\to n$ 中能被 $p _ { 1 } , p _ { 2 } , \cdots , p _ { m }$ 中的至少一个数整除的数有多少个？其中$m \leq 16 , n , p _ { i } \leq 10 ^ { 9 }$</p>
<p><strong>A</strong>：交集的大小等于 $n$ 除以质数的乘积。</p>
<p>​	$| S _ { 1 } | = \frac { n } { p _ { 1 } }$ ，$ | S _ { 1 } \cap S _ { 2 } | = \frac { n } { p _ { 1 } + p _ { 2 } } $，$ | S _ { 1 } \cap S _ { 2 } \cap S _ { 3 } | = \frac { n } { p _ { 1 }+ {  p _ { 2 } + p _ { 3 } } }$</p>
<p>​	若有 $3$ 个质数，就需要 $3$ 个二进制位来表示所有状态</p>
<p>​	$001 \rightarrow S _ { 1 }$ ， $010 \rightarrow S _ { 2 }$ ，$100 \rightarrow S _ { 3 }$</p>
<p>​	$011 \rightarrow S _ { 1 } \cap S _ { 2 }$ ， $101 \rightarrow S _ { 1 } \cap S _ { 3 }$ ， $011 \rightarrow S _ { 2 }\cap S _ { 3 } $</p>
<p>​	$111 \rightarrow S _ { 1 } \cap S _ { 2 }\cap S_{3}$ ， $000 \rightarrow \varnothing$</p>
<p>​	我们只要枚举从 $001$ 到 $111$ 的<strong>每个状态</strong>，就可以计算出全部交集的<strong>交错和</strong>。</p>
<p>​	时间复杂度： $O ( m * 2 ^ { m } )$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此代码需要针对特定问题研究</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n, m, prim[N];</span><br><span class="line"><span class="comment">// n代表范围</span></span><br><span class="line"><span class="comment">// 一共有m属性</span></span><br><span class="line"><span class="comment">// 容斥原理</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 集合元素个数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举状态 一共有 1 &lt;&lt; m 种状态，第0位~第m-1位都表示一种状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// t代表集合元素个数，sign代表符号</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 过滤状态</span></span><br><span class="line">        <span class="comment">//  注意j从0开始，查看每个集合的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="comment">// 状态为1代表选中</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span> &lt;&lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 比n大，直接为0</span></span><br><span class="line">                <span class="keyword">if</span> ((ll)t * prim[j] &gt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 质数的积</span></span><br><span class="line">                t *= prim[j];</span><br><span class="line">                <span class="comment">// 符号位相反</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// t不为0，计算答案</span></span><br><span class="line">        <span class="keyword">if</span> (t)</span><br><span class="line">            res += n / t * sign; <span class="comment">// 交集的和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集合的交">集合的交</h3>
<p><strong style="color:red;">集合的交等于全集减去补集的并</strong>，<strong>补集的并</strong>使用<strong>容斥原理</strong>求解</p>
<p>即 $\begin{aligned}<br>
\left|\bigcap_{i=1}^{n} S_{i}\right|= \left|U\right|- \left| \bigcup_{i=1}^{m} \overline {S_{i}}\right|<br>
\end{aligned}$</p>
<p>本质还是求集合的并，只是转换了思维；</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1450">洛谷 P1450 硬币购物</a></p>
<p><em>容斥原理思路</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此代码需要针对特定问题研究</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">// 容斥原理</span></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 集合元素个数</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 枚举状态 一共有 1 &lt;&lt; m 种状态，第0位~第m-1位都表示一种状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// t代表并集状态，sign代表符号</span></span><br><span class="line">        ll t = ......, sign = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 过滤状态</span></span><br><span class="line">        <span class="comment">//  注意j从0开始，查看每个集合的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">            <span class="comment">// 状态为1代表选中</span></span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span> &lt;&lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新并集状态</span></span><br><span class="line">                <span class="comment">// t......;</span></span><br><span class="line">                <span class="comment">// 符号位相反</span></span><br><span class="line">                sign = -sign;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 答案更新条件</span></span><br><span class="line">        <span class="keyword">if</span> (......)</span><br><span class="line">            res......;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ......;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="整除分块">整除分块</h2>
<h3 id="单变量整数分块">单变量整数分块</h3>
<p><em><strong>时间复杂度： $O(\sqrt n)$</strong></em></p>
<ul>
<li>求 $\sum\limits _ { i = 1 } ^ { n } \lfloor \dfrac { n } { i } \rfloor$ ；</li>
</ul>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308021715299.png" alt="image-20230802171523229"></p>
<p><strong>性质1</strong>：<strong>分块的块数 $≤2\lfloor\sqrt n\rfloor$</strong>  <em>保证时间复杂度</em></p>
<p>​	当 $i \le \lfloor\sqrt n\rfloor $ 时，$\lfloor \dfrac{n}{i} \rfloor$ 有 $\sqrt n$ 种取值</p>
<p>​	当 $i \le \lfloor\sqrt n\rfloor $ 时， $\lfloor \dfrac{n}{i} \rfloor \le \lfloor\sqrt n\rfloor$ ，$\lfloor \dfrac{n}{i} \rfloor$ 至多有 $\lfloor\sqrt n\rfloor$ 种取值；</p>
<p><strong>性质2</strong>： <strong>$i$ 所在块的右端点为 $\lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor$</strong>  <em>计算方法</em></p>
<p>​	 $i$ 所在块的值 $k=\lfloor \dfrac{n}{i} \rfloor$ ，则 $k \le \dfrac{n}{i}$ ，则  $\lfloor \dfrac{n}{k} \rfloor \ge \lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor=\lfloor i \rfloor =i$ ；</p>
<p>​	所以 $i_{max}=\lfloor \dfrac{n}{k} \rfloor = \lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor$ ；</p>
<p>​	代码实现 <code>r=n/(n/l)</code></p>
<ul>
<li>求 $\sum\limits _ { i = 1 } ^ { n } f(i)\cdot\lfloor \dfrac { n } { i } \rfloor$ ；</li>
</ul>
<p><em><strong>总时间复杂度： $O(n+\sqrt n)$</strong></em> （前缀和时间复杂度： $O(n)$ 整除分块时间复杂度 $O(\sqrt n)$）</p>
<p>先预处理出 $f(i)$ 的前缀和  $s(i)=\sum\limits ^i_{j=1}f(j)$ ，再枚举每一块 $[l,r]$ ，累加每块的贡献。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]为前缀和</span></span><br><span class="line"><span class="comment">// l=r+1为跳到下一块</span></span><br><span class="line"><span class="comment">// k为 i所在块的值</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注意 n/l==0 特判情况</span></span><br><span class="line">    <span class="comment">// if (k / 1 = 0)</span></span><br><span class="line">    <span class="comment">//     break;</span></span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    <span class="comment">// 当k&gt;n时候，可能会多算</span></span><br><span class="line">    <span class="comment">// r min(k / (k / 1), n);</span></span><br><span class="line">    res += (<span class="built_in">s</span>(r) - <span class="built_in">s</span>(l - <span class="number">1</span>)) * (n / l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双变量整数分块">双变量整数分块</h3>
<p><em><strong>总时间复杂度： $O(n+\sqrt n)$</strong></em> （前缀和时间复杂度： $O(n)$ 整除分块时间复杂度 $O(\sqrt n)$）</p>
<p>$ \left\lfloor\dfrac{\lfloor\tfrac{m}{k}\rfloor}{d}\right\rfloor =\left\lfloor\dfrac{m}{k d}\right\rfloor$</p>
<ul>
<li>求 $\sum\limits _ { i = 1 } ^ { n } f(i)\cdot\lfloor \dfrac { n } { i } \rfloor\cdot\lfloor \dfrac { m } { i } \rfloor$ ；（ $n \le m$ ，如果不满足，或许可以交换一下 $n$ 和 $m$ ）</li>
</ul>
<p>先预处理出 $f(i)$ 的前缀和  $s(i)=\sum \limits ^i_{j=1}f(j)$ ，再枚举每一块 $[l,r]$ ，累加每块的贡献。</p>
<img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202309031639182.png" alt="image-20230903163933010" style="zoom:50%;" />
<p>因此每次枚举应该取到 $\lfloor \dfrac { n } { l } \rfloor$ 和 $\lfloor \dfrac { m } { l} \rfloor$ 较小的那个一段，乘以对应的 $s(i)$ 进行累加。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]为前缀和</span></span><br><span class="line"><span class="comment">// l=r+1为跳到下一块</span></span><br><span class="line">ll res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 保证 n &lt;= m</span></span><br><span class="line"><span class="keyword">if</span> (n &gt; m)</span><br><span class="line">    <span class="built_in">swap</span>(n, m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取较小的一段的值</span></span><br><span class="line">    r = <span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">    res += <span class="number">1ll</span> * (s[r] - s[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// k为 i所在块的值</span></span><br><span class="line"><span class="comment">// 注意 n / l==0 特判情况</span></span><br><span class="line"><span class="comment">// if (k / 1 = 0)</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">// 当k &gt; n时候，可能会多算</span></span><br><span class="line"><span class="comment">// r min(k / (k / 1), n);</span></span><br></pre></td></tr></table></figure>
<h2 id="生成函数">生成函数</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">普通生成函数</th>
<th style="text-align:center">指数生成函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">$F ( x ) = \sum a _ { n } x ^ { n }$</td>
<td style="text-align:center">$F ( x ) = \sum a _ { n } \dfrac{x ^ { n }}{n!}$</td>
</tr>
<tr>
<td style="text-align:center">卷积</td>
<td style="text-align:center">$\sum \limits _ { i \ge 0 } a _ { i } x ^ { i } \sum \limits _ { j \ge 0 } b _ { j } x ^ { j } = \sum \limits _ { n \ge 0 } x ^ { n } \sum  \limits_ { i = 0 } ^ { n } a _ { i } b _ { n - i }$</td>
<td style="text-align:center">$\sum\limits _ { i \ge 0 } a _ { i } \dfrac { x ^ { i } } { i ! } \sum\limits _ { j \ge 0 } b _ { j  } \dfrac { x^j }{j!} = \sum\limits _ { n \ge 0 } \dfrac { x ^ { n } }{n!} \sum\limits _ { i = 0 } ^ { n } \dfrac { n ! } { i ! ( n - i ) ! } a _ { i } b _ { n - i }$</td>
</tr>
<tr>
<td style="text-align:center">构造</td>
<td style="text-align:center">$( 1 + x ^ { 1 } + \cdots + x ^ { a _ { 1 } } ) \cdots ( 1 + x ^ { 1 } + \cdots + x ^ { a _ { n } } )$</td>
<td style="text-align:center">$( 1 + \dfrac { x ^ { 1 } } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \cdots + \dfrac { x ^ { a _ { 1 } } } { a _ { 1 } ! } )\cdots ( 1 + \dfrac { x ^ { 1 } } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \cdots + \dfrac { x ^ { a _ { n } } } { a _ { n} ! } )$</td>
</tr>
<tr>
<td style="text-align:center">用途</td>
<td style="text-align:center">多重集组合数</td>
<td style="text-align:center">多重集排列数</td>
</tr>
<tr>
<td style="text-align:center">结果</td>
<td style="text-align:center">$x^m$ 的系数即组合数</td>
<td style="text-align:center">$\dfrac{x^m}{m!}$ 的系数即排列数</td>
</tr>
</tbody>
</table>
<h3 id="普通生成函数">普通生成函数</h3>
<p>$F ( x ) = \sum _ { n \geq 0 } a _ { n } x ^ { n }$</p>
<p><strong>加减操作（必须数量相同）：</strong></p>
<p>$ \begin{align}  F ( x ) \pm G ( x ) &amp;= \sum _ { i \ge 0 } a _ { i } x ^ { i } \pm \sum _ { j \geq 0 } b _ { j } x ^ { j }  \ &amp; = \sum _ { n \geq 0 } ( a _ { n } + b _ { n } ) x ^ { n } \end{align} $</p>
<p><strong>乘法操作（卷积）：</strong></p>
<p>$\begin{aligned}<br>
F(x) G(x) &amp; =\sum_{i \geq 0} a_{i} x^{i} \sum_{j \geq 0} b_{j} x^{j} \<br>
&amp; =\sum_{n \geq 0} x^{n} \sum_{i=0}^{n} a_{i} b_{n-i} \quad(\text { 令 } i+j=n)<br>
\end{aligned}$</p>
<p>例如 $n=3$ ，则 $x^3$ 的系数为 $a _ { 0 } b _ { 3 } + a _ { 1 } b _ { 2 } + a _ { 2 } b _ { 1 } + a _ { 3 } b _ { 0 }$</p>
<p>因此 $F(x)G(x)$ 是序列 $\lt \sum _ { i = 0 } ^ { n } a _ { i } b _ { n - i } \gt$ 的普通生成函数。</p>
<p><em>解决<strong>多重集组合数</strong>问题</em></p>
<p><strong>问题</strong>：有 $n$ 种物品，每种物品有 $a_i$ 个，问取 $m$ 个物品的<strong>组合数</strong>？</p>
<p>设从每种物品中取 $b_i$ 个， $0 \le b_i \le a_i$，对于一组选定的 $b_i$ 进行组合的方案数为 $1$。</p>
<p>例如，取 $3$ 个 $A$ 、 $1$ 个 $B$ 的方案就是 ${AAAB}$ ；取 $2$ 个 $A$ 、 $2$ 个 $B$ 的方案就是 ${AABB}$ 。</p>
<p>那么，所有满足 $b_1+b_2+\cdots+b_n=m$ 的方案之和，即答案。</p>
<p><strong>构造普通生成函数</strong></p>
<p>第 $1$ 种物品的生成函数为 $( 1 + x ^ { 1 } + x ^ { 2 } + \cdots + x ^ { a _ { 1 } } )$ ，第 $n$ 种物品的生成函数为 $( 1 + x ^ { 1 } + x ^ { 2 } + \cdots + x ^ { a _ { n } } )$</p>
<p>即求 $x^m$ 的系数。</p>
<p>*注意：<strong>指数</strong>即<strong>物品个数</strong>，<strong>系数</strong>即<strong>组合数</strong>。*灵活选取<strong>指数前面的系数</strong>！</p>
<p><strong>问题</strong>：有 $n$ 种水果，每种水果选购的个数在 $[a_i,b_i]$ 之间问，买 $m$ 个水果有多少种购买方案？</p>
<p>转化：构造生成函数 $( x ^ { a_1 } + \cdots + x ^ { b _ { 1 } } ) ( x ^ { a _ { 2 } } + \cdots + x ^ { b _ { 2 } } ) \cdots ( x ^  {a _ n } + \cdots + x ^ { b _ { n }   })$ ，求 $x^m$ 的系数。</p>
<p>代码模拟<strong>括号的展开</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;           <span class="comment">// n代表物品种数，m代表最终选取的个数</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>], b[<span class="number">110</span>]; <span class="comment">// 存幂次 幂次范围为a[i]~b[i]  下标从1开始</span></span><br><span class="line"><span class="type">int</span> C[<span class="number">110</span>], D[<span class="number">210</span>]; <span class="comment">// 存系数 C为系数结果 D为辅助数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化C[i]，D[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">        C[i] = D[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 给C填充第1项的系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a[<span class="number">1</span>]; i &lt;= b[<span class="number">1</span>]; ++i)</span><br><span class="line">        C[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从第2项开始枚举</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算x^j*x^k的系数 x^j系数是在C[j]存储，只需要计算到C[m]，大于m的对于结果没有影响</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="comment">// 当前括号 遍历x^k   改变指数的系数在这里！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = a[i]; k &lt;= b[i]; ++k)</span><br><span class="line">                <span class="comment">// x^j*x^k系数相乘，会得到新的x^(j+k)的系数</span></span><br><span class="line">                D[j + k] += C[j];</span><br><span class="line">        <span class="comment">// 转存C，清空D</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)</span><br><span class="line">            C[j] = D[j], D[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回选m的结果</span></span><br><span class="line">    <span class="keyword">return</span> C[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指数生成函数">指数生成函数</h3>
<p>$F ( x ) = \sum _ {n \ge 0} a _ { n ! } \frac { x ^ { n } } { n ! }$</p>
<p>序列 $&lt;1,1,1,\cdots&gt;$ 的指数生成函数是 $1 + \dfrac { x } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \dfrac { x ^ { 3 } } { 3 ! } + \cdots = \sum \limits _ { n \geq 0 } ^ { x ^ { n } } = e ^ { x }$</p>
<p>序列 $&lt;1 , p , p ^ { 2 },\cdots &gt;$ 的指数生成函数是 $1 + p \dfrac { x } { 1 ! } + p ^ { 2 } \dfrac { x ^ { 2 } } { 2 ! } + p ^ { 3 } \dfrac { x ^ { 3 } } { 3 ! } + \cdots = \sum _ { n \geq 0 } p ^ { n } \dfrac { x ^ { n } } { n ! } = e ^ { p x }$</p>
<p><strong>加减操作（必须数量相同）：</strong></p>
<p>$\left. \begin{align}  F ( x ) \pm G ( x ) &amp;= \sum _ { i \geq 0 } a _ { i } \frac { x ^ { i } } { i! } \pm \sum _ { j \geq 0 } b _ { j } \frac { x ^ { j } } { j ! }  \ &amp;= \sum _ { n \geq 0 } ( a _ { n } + b _ { n } ) \frac { x ^ { n } } { n ! }  \end{align} \right.$</p>
<p>因此 $F(x)±G(x)$ 是序列 $&lt;a_n±b_n&gt;$ 的指数生成函数。</p>
<p>$ \begin{align} F ( x ) G ( x ) &amp; = \sum \limits_ { i \ge 0 } a _ { i } \dfrac  { x ^ { i } }{i!} \sum \limits _ { j \geq 0 } b _ { j } \dfrac { x ^ { j } } { j ! } \&amp;= \sum _ { n \ge 0 } x ^ { n } \sum _ { i = 0 } ^ { n } a _ { i } b _ { n - i } \dfrac { 1 } { i ! ( n - i ) ! } \&amp;= \sum _ { n = 0 } \frac { x ^ { n } } { n ! } \sum _ { i = 0 } ^ { n } \frac { n ! } { i ! ( n - i ) ! } a _ { i } b _ { n - i } \&amp;= \sum _ { n \geq 0 } \frac { x ^ { n } } { n ! } \sum _ { i = 0 } ^ { n } C _ { n } ^ { i } a _ { i } b _ { n - i }\end{align} $</p>
<p>因此 $F(x)G(x)$ 是序列 $\lt \sum _ { i = 0 } ^ { n } C _ { n } ^ { i } a _ { i } b _ { n - i } \gt$ 的指数生成函数。</p>
<p><em>解决<strong>多重集排列数</strong>问题</em></p>
<p><strong>问题</strong>：有 $n$ 种物品，每种物品有 $a_i$ 个，问取 $m$ 个物品的<strong>排列数</strong>？</p>
<p>设从每种物品中取 $b _ { i }$ 个，$0 \leq b _ { i } \leq a _ { i }$ ，$m = \sum _ { i = 1 } ^ { n } b _ { i }$ ， 对于一组选定的 $b _ { i }$ 进行排列的方案数为 $\dfrac { m ! } { b _ { 1}  !b _ { 2 }! \cdots b _ { n } !}$</p>
<p>若 $m$ 个物品互不相同，其排列数为 $m!$ ，分母就是对每种相同物品的排列数去重。</p>
<p>例如</p>
<p>取 $3$ 个 $A$ 、 $1$ 个 $B$ 的排列数为 $\dfrac { 4 ! } { 3 ! 1 ! } = \dfrac { 24 } { 6 } = 4$ ，即 $&lt;!–swig￼28–&gt;{i^{x}} \sum_{j=1}^{\infty} \frac{b_{j}}{j^{x}} \<br>
= &amp; \left(\frac{a_{1}}{1^{x}}+\frac{a_{2}}{2^{x}}+\frac{a_{3}}{3^{x}}+\frac{a_{4}}{4^{x}}+\cdots\right)\left(\frac{b_{1}}{1^{x}}+\frac{b_{2}}{2^{x}}+\frac{b_{3}}{3^{x}}+\frac{b_{4}}{4^{x}}+\cdots\right) \<br>
= &amp; \frac{a_{1} b_{1}}{1^{x}}+\frac{a_{1} b_{2}+a_{2} b_{1}}{2^{x}}+\frac{a_{1} b_{3}+a_{3} b_{1}}{3^{x}}+\frac{a_{1} b_{4}+a_{2} b_{2}+a_{4} b_{1}}{4^{x}}+\cdots \<br>
= &amp; \sum_{n=1}^{\infty} \frac{1}{n^{x}} \sum_{d \mid n} a_{d} \frac{b_{n}}{d}<br>
\end{aligned}$</p>
<p>$\dfrac{1}{6^x} $ 的系数 $a _ { 1 } b _ { 6 } + a _ { 2 } b _ { 3 } + a _ { 3 } b _ { 2 } + a _ { 6 } b _ { 1 }$ （枚举 $6$ 的约数）</p>
<p><strong>欧拉函数</strong></p>
<p>$\varphi ( n ) = \sum\limits _ { i = 1 } ^ { n } [ \gcd ( i , n ) = 1 ]$</p>
<p>性质： $\sum\limits _ { d | n } \varphi ( d ) = n$</p>
<img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308072149337.png" alt="image-20230807214700821" style="zoom:50%;" />
<p><strong>莫比乌斯函数</strong></p>
<p>$\begin{align*}\begin{split}\mu(n)= \left {\begin{array}{lr}1,&amp; n=1\0,&amp; n含相同质因子\(-1)^s,&amp; s为n的不同质因子的个数\end{array}\right.\end{split}\end{align*}$</p>
<p>性质： $\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]$</p>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308102118189.png" alt="image-20230810211848076"></p>
<p>证明： $n=1$ 时， $d=1$ ， $\mu(1)=1$</p>
<p>当 $n&gt;1$ 时， $n = p _ { 1 } ^ { \alpha _ { 1 } } p _ { 2 } ^ { \alpha _ { 2 } } \cdots p _ { s } ^ { \alpha _ { s } }$ ，令 $n ^ { \prime } = p _ { 1 } p _ { 2 } \cdots p _ { s }$</p>
<p>$\sum \limits _ { d |n } \mu ( d ) = \sum \limits _ { d | n ^ { \prime } } \mu ( d )$ ，因为质因子重复会导致 $\mu(d)$ 为 $0$ 。</p>
<p>约数由质因子或乘积构成，根据容斥原理</p>
<p>不取任何质因子的方案数： $C_s^0$</p>
<p>取 $1$ 个质因子的方案数：$C_s^1$</p>
<p>取 $2$ 个质因子的方案数：$C_s^2$</p>
<p>$\dots$</p>
<p>$\begin{aligned}\sum \limits _ { d |n } \mu ( d ) &amp;= \sum \limits _ { d | n ^ { \prime } } \mu ( d )\&amp;= C^0_s + ( - 1 ) C^1_s + ( - 1 ) ^ { 2 } C^2_s + \cdots + ( - 1 ) ^ { s } C^s_s \&amp;=(1+(-1))^{s} \ &amp;=0\end{aligned} $</p>
<p><strong style="color:red;">欧拉函数和莫比乌斯函数的联系：$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } = \varphi ( n )$ </strong></p>
<p>证明： $n=1$ 时， $d=1$ ， $\mu(1)=\varphi(1)=1$</p>
<p>当 $n&gt;1$ 时， $n = p _ { 1 } ^ { \alpha _ { 1 } } p _ { 2 } ^ { \alpha _ { 2 } } \cdots p _ { s } ^ { \alpha _ { s } }$ ，令 $n ^ { \prime } = p _ { 1 } p _ { 2 } \cdots p _ { s }$</p>
<p>$\sum \limits _ { d |n } \mu ( d ) \dfrac{n}{d}= n\sum \limits _ { d | n ^ { \prime } }\dfrac{ \mu ( d )}{d}$ ，因为质因子重复会导致 $\mu(d)$ 为 $0$ 。</p>
<p>$\begin{align}\sum \limits _ { d |n } \mu ( d ) \dfrac{n}{d}&amp;= n\sum \limits _ { d | n ^ { \prime } }\dfrac{ \mu ( d )}{d} \<br>
&amp; = n\left(1-\left(\frac{1}{p_{1}}+\cdots+\frac{1}{p_{s}}\right)+\left(\frac{1}{p_{1} p_{2}}+\cdots+\frac{1}{p_{s-1} p_{s}}\right)-\cdots\right) \ &amp; = n\left(1-\frac{1}{p_{1}}\right)\left(1-\frac{1}{p_{2}}\right) \cdots\left(1-\frac{1}{p_{s}}\right) \ &amp; = \varphi(n)<br>
\end{align}$</p>
<h3 id="狄利克雷卷积">狄利克雷卷积</h3>
<p><strong>定义</strong>： $f ( n ) $ ， $ g ( n )$ 是两个积性函数，</p>
<p>$( f * g ) ( n ) = \sum \limits_ { d | _ { n } } f ( d ) g ( \dfrac { n } { d } ) = \sum\limits _ { d | n } f ( \dfrac { n } { d } ) g ( d )$</p>
<p><strong>规律</strong>：</p>
<ol>
<li>交换律： $f<em>g=g</em>f$</li>
<li>结合律： $(f<em>g)<em>h=f</em>(g</em>h)$</li>
<li>分配律： $(f+g)<em>h=f</em>h+g*h$</li>
</ol>
<p><strong>三个常用函数</strong>：</p>
<ol>
<li>元函数： $\varepsilon ( n ) = [ n = 1 ]$</li>
<li>常数函数： $1(n)=1$</li>
<li>恒等函数： $id(n)=x$</li>
</ol>
<p><strong>常用函数</strong>：</p>
<ol>
<li>$\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]\Leftrightarrow \mu*1=\varepsilon$</li>
<li>$\sum\limits _ { d | n } \varphi ( d ) = n \Leftrightarrow \varphi*1=id$</li>
<li>$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } = \varphi ( n ) \Leftrightarrow \mu*id=\varphi$</li>
<li>$f*\varepsilon=f$</li>
<li>$f*1\neq f$</li>
</ol>
<h2 id="和式的变换">和式的变换</h2>
<h3 id="和式的变换规则">和式的变换规则</h3>
<ol>
<li>分配律： $\sum \limits _ { k \in K } c a _ { k } = c \sum\limits _ { k \in K } a _ { k }$</li>
<li>结合律： $\sum \limits _ { k \in K } ( a _ { k } + b _ { k } ) = \sum \limits _ { k \in K } a _ { k } + \sum \limits _ { k \in K } b _ { k }$</li>
<li>交换律： $\sum \limits _ { k \in K } a _ { k } =  \sum\limits _ { p(k) \in K } a _ { p(k) }$ ， $p(k)$ 为指标集的任何一个排列</li>
</ol>
<h3 id="和式的变换技术">和式的变换技术</h3>
<ol>
<li>替换条件式</li>
</ol>
<p>$d|gcd(i,j)=[d|i][d|j]$</p>
<p>$\sum_\limits{i=1}^{n} \sum\limits_{j=1}^{m} \sum\limits_{d | \operatorname{gcd}(i, j)} d=\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} \sum\limits_{d=1}^{n}[d| i][d | j] d$ ，第二个式子内部 $\sum\limits_{d=1}^{n}[d|i][d |j] d$ ，上面的 $n$ 可以取任何大于的数 $\min(n,m)$</p>
<ol start="2">
<li>替换指标变量</li>
</ol>
<p>$\begin{align}\sum \limits_ { i = 1 } ^ { n } \sum \limits_ { j = 1 } ^ { m } [ g c d ( i , j ) = k ]&amp;=\sum \limits_ { ik = 1 } ^ { n } \sum \limits_ { jk = 1 } ^ { m } [ g c d ( ik , jk ) = k ]\&amp;=\sum \limits_ { ik = 1 } ^ { n } \sum \limits_ { jk = 1 } ^ { m } [ g c d ( i , j ) = 1\&amp;=\sum \limits_ { i = 1 } ^ { \lfloor\dfrac{n}{k} \rfloor} \sum \limits_ { j = 1 } ^ { \lfloor\dfrac{m}{k} \rfloor } [ g c d ( i , j ) = 1 ]\end{align}$</p>
<p>注意：最后一步的下标从 $1$ 开始的原因是，因为上一步的枚举是从 $1$ 开始的。</p>
<ol start="3">
<li>交换求和次序</li>
</ol>
<p>$\sum \limits_ { i = 1 } ^ { n } \sum \limits_ { j = 1 } ^ { m } A ( i ) B ( j ) = \sum \limits_ { j = 1 } ^ { m } \sum \limits_ { j = 1 } ^ { n } A ( i ) B ( j )$</p>
<ol start="4">
<li>分离变量</li>
</ol>
<p>$\sum \limits_ { i = 1 } ^ { n } \sum \limits_ { j = 1 } ^ { m } A ( i ) B ( j ) = \sum \limits_ { j = 1 } ^ { m }A(i) \sum \limits_ { j = 1 } ^ { n } B ( j )$</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3455">洛谷 P3455 POI2007 ZAP-Queries</a></p>
<h3 id="和式的变换技巧">和式的变换技巧</h3>
<ol>
<li><strong>莫比乌斯函数的性质</strong></li>
</ol>
<p><strong style="color:red;">$\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]\Longleftrightarrow [ \gcd(i,j) = 1 ]=\sum\limits _ { d | \gcd(i,j) } \mu( d )  $  </strong></p>
<ol start="2">
<li><strong>整除性质</strong></li>
</ol>
<p>$\sum \limits_ { i=1 } ^ { n } [d|i]=\lfloor \dfrac{n}{d}\rfloor$ ，容易转化为<strong>整除分块</strong>求 $\sum\limits _ { i = 1 } ^ { n } f(i)\cdot\lfloor \dfrac { n } { i } \rfloor$</p>
<ol start="3">
<li><strong>求 $\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m}[\gcd(i,j)=k]$</strong></li>
</ol>
<p>$\sum _ \limits{ i = 1 } ^ { n } \sum \limits_ { j = 1 } ^ { m } [ g c d ( i , j ) = k ]=\sum_\limits{d=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \mu(d)\left\lfloor\dfrac{n}{k d}\right\rfloor\left\lfloor\dfrac{m}{k d}\right\rfloor$ （ $n&lt;m$ ）</p>
<p>证明：</p>
<p>当 $k=1$ 时，</p>
<p>$ \begin{align}&amp;\sum_{i = 1}^{n} \sum_{j = 1}^{m}[\operatorname{gcd}(i, j) = 1]<br>
\ = &amp; \sum_{i = 1}^{n} \sum_{j = 1}^{m} \sum_{d \mid \operatorname{gcd}(i, j)} \mu(d)<br>
\ = &amp;\sum_{i = 1}^{n} \sum_{j = 1}^{m} \sum_{d = 1}^{n}[d \mid i][d \mid j] \mu(d)<br>
\ = &amp;\sum_{d = 1}^{n} \mu(d) \sum_{i = 1}^{n}[d \mid i] \sum_{j = 1}^{m}[d \mid j]<br>
\ = &amp;\sum_{d = 1}^{n} \mu(d)\left\lfloor\dfrac{n}{d}\right\rfloor\left\lfloor\dfrac{m}{d}\right\rfloor \end{align}$</p>
<p>当 $k\neq 1$ 时，</p>
<p>$ \begin{align}&amp;\sum_{i = 1}^{n} \sum_{j = 1}^{m}[\operatorname{gcd}(i, j) = k]                    \ = &amp; \sum \limits_ { i = 1 } ^ { \lfloor\dfrac{n}{k} \rfloor} \sum \limits_ { j = 1 } ^ { \lfloor\dfrac{m}{k} \rfloor } [ g c d ( i , j ) = 1 ]\end{align} $</p>
<p>其实到这一步，已经转化为 $k=1$ 的情况了，只不过 $n$ 需要替换为 $\lfloor\dfrac{n}{k}\rfloor$ ， $m$ 需要替换为 $\lfloor\dfrac{m}{k}\rfloor$ 。</p>
<p>即结果可以得到 $\sum \limits_{d = 1}^{\lfloor\tfrac{n}{k}\rfloor} \mu(d)\left\lfloor\dfrac{\lfloor\tfrac{n}{k}\rfloor}{d}\right\rfloor\left\lfloor\dfrac{\lfloor\tfrac{m}{k}\rfloor}{d}\right\rfloor= \sum\limits_{d = 1}^{\lfloor\tfrac{n}{k} \rfloor} \mu(d)\left\lfloor\dfrac{n}{kd}\right\rfloor\left\lfloor\dfrac{m}{kd}\right\rfloor $ （$ \left\lfloor\dfrac{\lfloor\tfrac{m}{k}\rfloor}{d}\right\rfloor =\left\lfloor\dfrac{m}{k d}\right\rfloor$ ）</p>
<p>继续往下写：</p>
<p>$\begin{align}\ = &amp; \sum_{i = 1}^{\lfloor\tfrac{n}{k} \rfloor} \sum_{j = 1}^{\lfloor\tfrac{m}{k} \rfloor} \sum_{d | \operatorname{gcd}(i, j)} \mu(d)<br>
\ = &amp;\sum_{i = 1}^{\lfloor\tfrac{n}{k} \rfloor} \sum_{j = 1}^{\lfloor\tfrac{m}{k} \rfloor} \sum_{d = 1}^{\lfloor\tfrac{n}{k} \rfloor}[d | i][d | j] \mu(d)<br>
\ = &amp;\sum_{d = 1}^{\lfloor\tfrac{n}{k} \rfloor} \mu(d) \sum_{i = 1}^{\lfloor\tfrac{n}{k} \rfloor}[d| i] \sum_{j = 1}^{\lfloor\tfrac{m}{k} \rfloor}[d |j]<br>
\ = &amp;\sum_{d = 1}^{\lfloor\tfrac{n}{k} \rfloor} \mu(d)\left\lfloor\dfrac{n}{kd}\right\rfloor\left\lfloor\dfrac{m}{kd}\right\rfloor \end{align}$</p>
<p>然后利用<strong>双变量整数分块</strong>求结果。</p>
<ol start="4">
<li><strong>求 $\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m}[\gcd(i,j)\in \text{prim}]$</strong></li>
</ol>
<p>$\begin{align}<br>
&amp;\sum_{i=1}^{n} \sum_{j=1}^{m}[\operatorname{gcd}(i, j) \in \text {prim}] \<br>
=&amp;\sum_{i=1}^{n} \sum_{j=1}^{m} \sum_{k=1}^{n}[\operatorname{gcd}(i, j)=k][k \in \text {prim}] \<br>
=&amp;\sum_{k=1}^{n} \sum_{i=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\tfrac{m}{k}\right\rfloor}[\operatorname{gcd}(i, j)=1][k \in \text {prim}] \<br>
=&amp;\sum_{k=1}^{n} \sum_{i=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\tfrac{m}{k}\right\rfloor} \sum_{d \mid \operatorname{gcd}(i, j)} \mu(d)[k \in \text {prim}] \<br>
=&amp;\sum_{k=1}^{n} \sum_{i=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \sum_{j=1}^{\left\lfloor\tfrac{m}{k}\right\rfloor} \sum_{d=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor}[d | i][d | j] \mu(d)[k \in \text {prim}] \<br>
=&amp;\sum_{k=1}^{n} \sum_{d=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \mu(d) \sum_{i=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor}[d|i] \sum_{j=1}^{\left\lfloor\tfrac{m}{k}\right\rfloor}[d | j][k \in \text {prim}] \=&amp;\sum\limits_{k=1}^n\sum\limits_{d=1}^{\lfloor\tfrac{n}{k}\rfloor}\mu(d)\lfloor\dfrac{n}{kd}\rfloor\lfloor\dfrac{m}{kd}\rfloor[k \in \text{prim}]\end{align}$</p>
<p>因为分母有 $k,d$ 两个变量，所以此时还无法使用整除分块，可以整体代换让他可以使用整除分块。</p>
<p><strong style="color:red;">令 $T=kd$ ，则 $d=\dfrac{T}{k}$ ，代换 $d$ 的原因，是因为原式中有 $\lfloor \dfrac{n}{k} \rfloor$ ，这样代换可以消去 $k$ 。</strong></p>
<p>$\begin{align}<br>
=&amp;\sum_{k=1}^{n} \sum_{\tfrac{T}{k}=1}^{\left\lfloor\tfrac{n}{k}\right\rfloor} \mu\left(\frac{T}{k}\right)\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor[k \in \text {prim}] \<br>
=&amp;\sum_{k=1}^{n} \sum_{T=1}^{n} \mu\left(\frac{T}{k}\right)\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor[k \in \text {prim}] \<br>
=&amp;\sum_{T=1}^{n}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor \sum_{k=1}^{n} \mu\left(\frac{T}{k}\right)[k \in \text {prim}] \<br>
=&amp;\sum_{T=1}^{n}\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor \sum_{k \in \text {prim}} \mu\left(\frac{T}{k}\right)\=&amp;\sum_{T=1}^{n}\sum_{k \in \text {prim}} \mu\left(\frac{T}{k}\right)\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor<br>
\end{align}$</p>
<p>然后先预处理 $s(x)=\sum\limits_{k \in \text {prim}} \mu\left(\dfrac{T}{k}\right)$ ，使用双变量整除分块即可。</p>
<p>大致时间复杂度： $n(\dfrac{1}{2}+\dfrac{1}{3}+\cdots)\approx O(n\ln\ln n)$</p>
<ol start="5">
<li><strong>求$\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m}d(ij)$</strong>， $d(x)$ 为约数个数。</li>
</ol>
<p>结论： $d(ij)=\sum\limits_{x|i} \sum\limits_{y|j}[\gcd(x,y)=1]$</p>
<p>$\begin{aligned}<br>
&amp; \sum_{i=1}^{n} \sum_{j=1}^{m} d(i j) \<br>
= &amp; \sum_{i=1}^{n} \sum_{j=1}^{m} \sum_{x \mid i} \sum_{y \mid j}[\operatorname{gcd}(x, y)=1] \<br>
= &amp; \sum_{i=1}^{n} \sum_{j=1}^{m} \sum_{x=1}^{n} \sum_{y=1}^{m}[x |i][y | j][\operatorname{gcd}(x, y)=1] \<br>
= &amp; \sum_{x=1}^{n} \sum_{y=1}^{m} \sum_{i=1}^{n}[x | i] \sum_{j=1}^{m}[y | j][\operatorname{gcd}(x, y)=1] \<br>
= &amp; \sum_{x=1}^{n} \sum_{y=1}^{m} \lfloor \frac{n}{x}\rfloor \lfloor  \frac{m}{y}\rfloor[\operatorname{gcd}(x, y)=1] \<br>
= &amp; \sum_{x=1}^{n} \sum_{y=1}^{m} \rfloor \frac{n}{x}\rfloor \lfloor  \frac{m}{y}\rfloor \sum_{d=1}^{n}[d |x][d|y] \mu(d) \<br>
= &amp; \sum_{d=1}^{n} \mu(d) \sum_{x=1}^{n}\lfloor\frac{n}{x}\rfloor[d | x] \sum_{y=1}^{m} \lfloor \frac{m}{y}\rfloor[d | y]<br>
\end{aligned}$</p>
<p>因为： $\sum\limits_{d=1}^{n}\sum\limits_{x=1}^{n}\lfloor \dfrac{n}{x}\rfloor[d|x]=\sum\limits_{d=1}^{n}\sum\limits_{dx=1}^{n}\lfloor\dfrac{n}{dx}\rfloor$</p>
<p>即将 $x \rightarrow dx,y \rightarrow dy$</p>
<p>$\begin{aligned}&amp;=\sum\limits_{d=1}^{n}\mu(d)\sum\limits_{dx=1}^{n}\lfloor\dfrac{n}{dx}\rfloor\sum\limits_{dy=1}^{m}\lfloor\dfrac{m}{dy}\rfloor\&amp;=\sum\limits_{d=1}^{n}\mu(d)\sum\limits_{x=1}^{\lfloor \tfrac{n}{d}\rfloor}\lfloor\dfrac{n}{dx}\rfloor\sum\limits_{y=1}^{\lfloor \tfrac{m}{d}\rfloor}\lfloor\dfrac{m}{dy}\rfloor\end{aligned}$</p>
<p>令 $F ( n ) = \sum \limits_ { i = 1 } ^ { n } \lfloor\dfrac { n } { l } \rfloor$</p>
<p>$=\sum\limits_{d=1}^{n}\mu(d)F(\lfloor\dfrac{n}{d}\rfloor)F(\lfloor\dfrac{m}{d}\rfloor)$</p>
<p>预处理 $\mu(d)$ 前缀和，复杂度为 $O(n)$</p>
<p>对于每个 $n$ 利用<strong>单变量整数分块</strong>求 $F(n)$ ，复杂度为 $O(n\sqrt n)$</p>
<p>查询结果利用<strong>双变量整数分块</strong>，复杂度为为 $O(\sqrt n)$</p>
<ol start="6">
<li><strong>求 $\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m}f(\gcd(i,j))$</strong></li>
</ol>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>$f ( n ) = \sum \limits_ { d | n } g ( d ) \Leftrightarrow g ( n ) = \sum \limits_ { d |n } \mu ( d ) f ( \dfrac { n } { d } )$</p>
<p>$f(n),g(n)$ 均为积性函数</p>
<p>$f(n) \xLeftrightarrow[g为f的莫比乌斯逆变换]{f为g的莫比乌斯变换} g(n)$</p>
<p>证明1：</p>
<p>若 $f=g<em>1$ ，则 $\mu</em>f=\mu<em>g</em>1=g*\mu<em>1=g</em>\varepsilon=g$</p>
<p>若 $g=\mu<em>f$ ，则 $g</em>1=\mu<em>f</em>1=f*\mu<em>1=f</em>\varepsilon=f$</p>
<p>证明2：</p>
<p><strong>三个常用函数</strong>：</p>
<ol>
<li>元函数： $\varepsilon ( n ) = [ n = 1 ]$</li>
<li>常数函数： $1(n)=1$</li>
<li>恒等函数： $id(n)=x$</li>
</ol>
<p><strong>常用函数</strong>：<br>
<strong style="color:red;">1.  $\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]\Leftrightarrow \mu*1=\varepsilon$ </strong></p>
<ol start="2">
<li>$\sum\limits _ { d | n } \varphi ( d ) = n \Leftrightarrow \varphi*1=id$</li>
<li>$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } = \varphi ( n ) \Leftrightarrow \mu*id=\varphi$</li>
<li>$f*\varepsilon=f$</li>
<li>$f*1\neq f$</li>
</ol>
<p>$\begin{align}<br>
\sum_{d \mid n} \mu(d) f\left(\dfrac{n}{d}\right) &amp; = \sum_{d \mid n} \mu(d) \sum_{k \mid \tfrac{n}{d}} g(k) \ &amp; = \sum_{d \mid n} \sum_{k \mid \tfrac{n}{d}} \mu(d) g(k)\ &amp; = \sum_{k \mid n} \sum_{d \mid \tfrac{n}{k}} \mu(d) g(k) \ &amp; = \sum_{k \mid n} g(k) \sum_{d \mid \tfrac{n}{k}} \mu(d) \&amp; = g(n)<br>
\end{align}$</p>
<p>重点在于第2，3行之间的交换 $k$ 和 $d$ ，因为 $n$ 是固定，若 $k,d$ 一方为 $n$ 的因子，另一方就是枚举这一方的因子，本质是一样的，所以可以交换位置。</p>
<h2 id="杜教筛">杜教筛</h2>
<p><em><strong>时间复杂度： $O(n^{\tfrac{2}{3}})$</strong></em></p>
<blockquote>
<p>时间复杂度的证明：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/521699400">杜教筛</a></p>
</blockquote>
<p>求 $s ( n ) = \sum \limits_ { i = 1 } ^ { n } f ( i )$ ， $f$ 为积性函数</p>
<p>构造极性函数 $g$ ，使得 $f*g$ 的前缀和容易计算</p>
<p>根据递推式： <strong style="color:red;">$g ( 1 ) s ( n ) = \sum \limits _ { i = 1 } ^ { n } ( f * g ) ( i ) - \sum \limits _ { i = 2 } ^ { n } g ( i ) s ( \dfrac { n } { i } )$ </strong></p>
<p>递归计算 $s(n)$ 。</p>
<h4 id="优化">优化</h4>
<ol>
<li>使用线性筛预处理 $n$ 较小时的 $s(n)$ 来剪枝</li>
<li>使用哈希表做记忆化剪枝</li>
<li>使用整除分块做递归</li>
</ol>
<h4 id="递推式证明"><strong>递推式证明</strong></h4>
<p><strong>狄利克雷卷积</strong>：</p>
<p>$( f * g ) ( n ) = \sum \limits_ { d | _ { n } } f ( d ) g ( \dfrac { n } { d } ) = \sum\limits _ { d | n } f ( \dfrac { n } { d } ) g ( d )$</p>
<p>证明：</p>
<p>$\begin{array}{l}<br>
\sum\limits_{i=1}^{n}(f * g)(i) \<br>
=\sum\limits_{i=1}^{n} \sum\limits_{d \mid i} f\left(\frac{i}{d}\right) g(d)=\sum\limits_{i=1}^{n} \sum\limits_{d=1}^{n}[d \mid i] f\left(\frac{i}{d}\right) g(d) \<br>
=\sum\limits_{d=1}^{n} \sum\limits_{i=1}^{n}[d \mid i] f\left(\frac{i}{d}\right) g(d)=\sum\limits_{d=1}^{n} \sum\limits_{i d=1}^{n}[d | i d] f\left(\tfrac{i d}{d}\right) g(d) \<br>
=\sum\limits_{d=1}^{n} \sum\limits_{i=1}^{\lfloor \tfrac{n }{ d}\rfloor} f(i) g(d)=\sum\limits_{d=1}^{n} g(d) s\left(\dfrac{n}{d}\right) \<br>
=g(1) s(n)+\sum\limits_{d=2}^{n} g(d) s\left(\dfrac{n}{d}\right)\cdots\cdots分离第一项<br>
\end{array}$</p>
<h4 id="技巧">技巧</h4>
<p><strong>三个常用函数</strong>：</p>
<ol>
<li>元函数： $\varepsilon ( n ) = [ n = 1 ]$</li>
<li>常数函数： $1(n)=1$</li>
<li>恒等函数： $id(n)=x$</li>
</ol>
<p><strong>常用函数</strong>：</p>
<ol>
<li>$\sum\limits _ { d | n } \mu( d ) = [ n = 1 ]\Leftrightarrow \mu*1=\varepsilon$</li>
<li>$\sum\limits _ { d | n } \varphi ( d ) = n \Leftrightarrow \varphi*1=id$</li>
<li>$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } = \varphi ( n ) \Leftrightarrow \mu*id=\varphi$</li>
</ol>
<h4 id="求-s-n-sum-limits-n-i-1-varphi-i">求 $s(n)=\sum\limits^n_{i=1}\varphi(i)$</h4>
<p>因为 $\varphi<em>1=id$ ，则 $f=\varphi$ ，$g=1$ ， $f</em>g=id$</p>
<p>$\begin{align}s(n)&amp;=\sum\limits^n_{i=1}id(i)-\sum\limits^n_{i=2}1(i)s(\dfrac{n}{i})\&amp;=\sum\limits^n_{i=1}i-\sum\limits^n_{i=2}s(\dfrac{n}{i})\&amp;=\dfrac{n(n+1)}{2}-\sum\limits^n_{i=2}s(\dfrac{n}{i})\end{align}$</p>
<p>最后对 $s(\dfrac{n}{i})=s(\lfloor\dfrac{n}{i}\rfloor)$ 用哈希表存，再做分块做递归处理即可。</p>
<h4 id="求-s-n-sum-limits-n-i-1-mu-i">求 $s(n)=\sum\limits^n_{i=1}\mu(i)$</h4>
<p>因为 $\mu<em>1=\varepsilon$ ，则 $f=\mu$ ，$g=1$ ， $f</em>g=\varepsilon$</p>
<p>$s(n)=\sum\limits^n_{i=1}\varepsilon(i)-\sum\limits^n_{i=2}1(i)s(\dfrac{n}{i})=1-\sum\limits^n_{i=2}s(\dfrac{n}{i})$</p>
<p>最后对 $s(\dfrac{n}{i})=s(\lfloor\dfrac{n}{i}\rfloor)$ 用哈希表存，再做分块做递归处理即可。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// N取约n^&#123;2/3&#125;，预处理n的三分之二次方</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>;</span><br><span class="line">ll vis[N], pm[N], mu[N], phi[N], cnt;</span><br><span class="line">map&lt;ll, ll&gt; mp_mu, mp_phi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理mu和phi函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pm[++cnt] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; i * pm[j] &lt; N; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p = pm[j];</span><br><span class="line">            vis[i * p] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * p] = phi[i] * p;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mu[i * p] = -mu[i];</span><br><span class="line">            phi[i * p] = phi[i] * (p - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求s(n)(phi)</span></span><br><span class="line"><span class="function">ll <span class="title">Sphi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; N)</span><br><span class="line">        <span class="keyword">return</span> phi[n]; <span class="comment">// 预处理的剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (mp_phi[n])</span><br><span class="line">        <span class="keyword">return</span> mp_phi[n]; <span class="comment">// 记忆化剪枝</span></span><br><span class="line">    <span class="comment">// 手动计算</span></span><br><span class="line">    ll ans = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 整数分块</span></span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans -= <span class="built_in">Sphi</span>(n / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp_phi[n] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求s(n)(mu)</span></span><br><span class="line"><span class="function">ll <span class="title">Smu</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; N)</span><br><span class="line">        <span class="keyword">return</span> mu[n]; <span class="comment">// 预处理的剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (mp_mu[n])</span><br><span class="line">        <span class="keyword">return</span> mp_mu[n]; <span class="comment">// 记忆化剪枝</span></span><br><span class="line">    <span class="comment">// 手动计算</span></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 整数分块</span></span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">2</span>, r; l &lt;= n; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        ans -= <span class="built_in">Smu</span>(n / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mp_mu[n] = ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间">命名空间</h4>
<p>采用模板设计模式，将杜教筛的部分提取到父类 <code>DJSeive</code> 中，这部分是不需要变的。提供三个接口（虚函数），需要子类实现。<code>gsum</code> 是求 $g$ 的区间和，<code>hsum</code> 是求 $h$ 得前缀和，<code>precal</code> 是预计算部分。</p>
<p>该实现可以实现同时求多个前缀和。使用模板元编程让返回类型当只求一个时，采用 <code>int64_t</code> 类型，当求多个时，采用 <code>array&lt;int64_t, N&gt;</code> 类型。</p>
<p>重载了 <code>array&lt;T, N&gt;</code> 的一些操作，让 <code>array</code> 的操作和普通数保持一致。</p>
<p>模板为洛谷P4213，求 $\mu$ 和 $\varphi$ 的前缀和。要求其他函数，只需修改子类中对应 <code>gsum</code>，<code>hsum</code> ，<code>precal</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.luogu.com.cn/problem/P4213</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">array&lt;T, N&gt; <span class="keyword">operator</span>+(<span class="type">const</span> array&lt;T, N&gt; &amp;a, <span class="type">const</span> array&lt;T, N&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    array&lt;T, N&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">array&lt;T, 2&gt; <span class="keyword">operator</span>+(<span class="type">const</span> array&lt;T, <span class="number">2</span>&gt; &amp;a, <span class="type">const</span> array&lt;T, <span class="number">2</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] + b[<span class="number">0</span>], a[<span class="number">1</span>] + b[<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line">array&lt;T, N&gt; <span class="keyword">operator</span>*(<span class="type">const</span> array&lt;T, N&gt; &amp;a, <span class="type">const</span> array&lt;T, N&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    array&lt;T, N&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res[i] = a[i] * b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">array&lt;T, 2&gt; <span class="keyword">operator</span>*(<span class="type">const</span> array&lt;T, <span class="number">2</span>&gt; &amp;a, <span class="type">const</span> array&lt;T, <span class="number">2</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;a[<span class="number">0</span>] * b[<span class="number">0</span>], a[<span class="number">1</span>] * b[<span class="number">1</span>]&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>-=(array&lt;T, N&gt; &amp;a, <span class="type">const</span> array&lt;T, N&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] -= b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> <span class="keyword">operator</span>-=(array&lt;T, <span class="number">2</span>&gt; &amp;a, <span class="type">const</span> array&lt;T, <span class="number">2</span>&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a[<span class="number">0</span>] -= b[<span class="number">0</span>];</span><br><span class="line">    a[<span class="number">1</span>] -= b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DJSeive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> PRECALUB;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line">    <span class="keyword">using</span> result_type = <span class="type">conditional_t</span>&lt;(N &gt; <span class="number">1</span>), array&lt;<span class="type">int64_t</span>, N&gt;, <span class="type">int64_t</span>&gt;;</span><br><span class="line">    vector&lt;result_type&gt; sumf;</span><br><span class="line">    unordered_map&lt;<span class="type">int64_t</span>, result_type&gt; w;</span><br><span class="line">    vector&lt;result_type&gt; f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DJSeive</span>(<span class="type">int64_t</span> n) : <span class="built_in">PRECALUB</span>(<span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3</span>)),</span><br><span class="line">                         <span class="built_in">f</span>(PRECALUB + <span class="number">1</span>),</span><br><span class="line">                         <span class="built_in">sumf</span>(PRECALUB + <span class="number">1</span>),</span><br><span class="line">                         <span class="built_in">vis</span>(PRECALUB + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">precal</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> result_type <span class="title">gsum</span><span class="params">(<span class="type">int64_t</span> l, <span class="type">int64_t</span> r)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> result_type <span class="title">hsum</span><span class="params">(<span class="type">int64_t</span> n)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杜教筛递归</span></span><br><span class="line">    <span class="function">result_type <span class="title">fsum</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= PRECALUB)</span><br><span class="line">            <span class="keyword">return</span> sumf[x];</span><br><span class="line">        <span class="keyword">if</span> (w.<span class="built_in">count</span>(x))</span><br><span class="line">            <span class="keyword">return</span> w[x];</span><br><span class="line">        result_type ans = <span class="built_in">hsum</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int64_t</span> l = <span class="number">2</span>, r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(l != <span class="number">0</span>);</span><br><span class="line">            r = x / (x / l);</span><br><span class="line">            ans -= <span class="built_in">gsum</span>(l, r) * <span class="built_in">fsum</span>(x / l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w[x] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DJSeiveImpl</span> : <span class="keyword">public</span> DJSeive&lt;<span class="number">2</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// precal要在子类调用，因为它是虚函数</span></span><br><span class="line">    <span class="built_in">DJSeiveImpl</span>(<span class="type">int64_t</span> n) : <span class="built_in">DJSeive</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">precal</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g的范围求和</span></span><br><span class="line">    <span class="function">result_type <span class="title">gsum</span><span class="params">(<span class="type">int64_t</span> l, <span class="type">int64_t</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;r - l + <span class="number">1</span>, r - l + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// h前缀和</span></span><br><span class="line">    <span class="function">result_type <span class="title">hsum</span><span class="params">(<span class="type">int64_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, n * (n + <span class="number">1</span>) / <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">precal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// mu phi</span></span><br><span class="line">        f[<span class="number">1</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= PRECALUB; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">                f[i] = &#123;<span class="number">-1</span>, i - <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p * <span class="built_in">int64_t</span>(i) &gt; PRECALUB)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                vis[i * p] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i * p][<span class="number">1</span>] = f[i][<span class="number">1</span>] * p;</span><br><span class="line">                    <span class="comment">// phi[i * p] = phi[i] * p;</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// mu[i * p] = -mu[i];</span></span><br><span class="line">                    f[i * p][<span class="number">0</span>] = -f[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// phi[i * p] = phi[i] * (p - 1);</span></span><br><span class="line">                    f[i * p][<span class="number">1</span>] = f[i][<span class="number">1</span>] * (p - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= PRECALUB; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sumf[i] = sumf[i - <span class="number">1</span>] + f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="function">DJSeiveImpl <span class="title">seive</span><span class="params">(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        array&lt;<span class="type">int64_t</span>, 2&gt; res = seive.<span class="built_in">fsum</span>(n);</span><br><span class="line">        cout &lt;&lt; res[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速傅里叶变换-FFT">快速傅里叶变换(FFT)</h2>
<h3 id="复数">复数</h3>
<p>定义： $z=x+iy$ ，其中 $i^2=-1$</p>
<p>加法： $z_1+z_2=(x_1+x_2)+i(y_1+y_2)$</p>
<p>减法： $z_1-z_2=(x1-x2)+i(y_1-y_2)$</p>
<p>乘法： $z_1*z_2=(x_1x_2-y_1y_2)+i(x_1y_2+x_2y_1)$</p>
<h3 id="单位圆-单位根">单位圆/单位根</h3>
<p><strong>单位圆</strong>是指复平面上圆心在原点且半径为 $1$ 的圆</p>
<p>圆上的点： $z=\cos\theta+i\sin\theta,(0\le\theta&lt;2\pi)$</p>
<p>把圆 $n$ 等分，可得方程 $z^n=1$ 的 $n$ 个复数解，即单位根</p>
<p><strong>单位根</strong></p>
<p><strong style="color:gray;"><em>下面的 $\omega^k_n$ 上标代表第 $k$​ 个单位根，不是次方</em></strong></p>
<p>$\large \omega^k_n=\cos\dfrac{2\pi k}{n}+i\sin \dfrac{2\pi k}{n},(0\le k&lt;n)$</p>
<p>$\large \omega^k_n\omega^m_n=\omega^{k+m}_n,(\omega^k_n)^m=\omega^{km}_n$</p>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202309212056575.png" alt="image-20230921205553454"></p>
<h3 id="FFT基础">FFT基础</h3>
<p>FFT要求<strong>单位根</strong>等分<strong>单位圆</strong> $\large n=2^{b\in N}$</p>
<p>性质：</p>
<ol>
<li>周期性 $\large \omega^{k+m}_n=\omega^k_n$</li>
<li>对称性 $\large \omega^{k+\tfrac{n}{2}}=-\omega^k_n$</li>
<li>折半性 $\large \omega^{2k}<em>n=\omega^k</em>{\tfrac{n}{2}}$</li>
</ol>
<h3 id="由系数求点值（正变换）">由系数求点值（正变换）</h3>
<p>设 $A(x)$ 的系数为 $(a_0,a_1,a_2,\cdots,a_{n-1})$</p>
<p>$\begin{align}A(x)&amp;=a_0+a_1x+a_2x^2+a_3x^3+\cdots+a_{n-1}x^{n-1}\&amp;=()\cdots\cdots偶数项\&amp;+(a_1+a_3x^2+\cdots+a_{n-1}x^{n-2})x\cdots\cdots奇数项\end{align}$</p>
<p>令$A_1(x)=a_0+a_2x+\cdots+a_{n-2}x^{\tfrac{n}{2}-1}$</p>
<p>令$A_2(x)=a_1+a_3x+\cdots+a_{n-1}x^{\tfrac{n}{2}-1}$</p>
<p>则 $A(x)=A_1(x^2)+A_2(x^2)x$</p>
<p>前半圈：</p>
<p>将 $\large\omega^k_n,(k&lt;\frac{n}{2})$ 带入得</p>
<p>$A(\omega^k_n)=A_1(\omega^{2k}_n)+A_2(\omega^{2k}_n)\omega^{2k}_n$</p>
<p>后半圈：</p>
<p>将 $\large\omega^{k+\tfrac{n}{2}}_n,(k&lt;\frac{n}{2})$ 带入得</p>
<p>$A(\omega^k_n)=A_1(\omega^{2k}_n)+A_2(\omega^{2k}_n)\omega^{2k}_n$</p>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202309212138198.png" alt="image-20230921213818015"></p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="/img/pwa/favicon.ico"></a><div class="post-copyright__author_name">Lumosion's Blog</div><div class="post-copyright__author_desc"></div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">Lumosion's Blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/21/%E6%A0%91%E8%AE%BA/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">树论</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/21/jiangly%E6%9D%BF%E5%AD%90/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">jiangly板子</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/avatar.png"><div class="avatar-sticker"><img class="avatar-sticker-img" src="https://7.isyangs.cn/34/65f2e4e0423cc-34.png" alt="心情贴纸"></div></div><div class="author-info__description_group"><div class="author-info__description">分享自己对编程的<b>热爱</b>，对美好生活的<b>向往</b>，对知识海洋<b>探索历程</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的知识和教程。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">Lumosion</div><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4"><span class="toc-text">高精度加减乘除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8F%96%E6%A8%A1%EF%BC%88%E7%A7%A6%E4%B9%9D%E9%9F%B6%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">高精度取模（秦九韶算法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82-%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1"><span class="toc-text">快速幂 快速幂取模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-text">矩阵快速幂</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88GCD%EF%BC%89"><span class="toc-text">最大公约数-欧几里得算法（GCD）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0"><span class="toc-text">质数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0-%E8%AF%95%E9%99%A4%E6%B3%95"><span class="toc-text">判断素数-试除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-text">分解质因数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%9B%E6%B3%95"><span class="toc-text">筛法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95"><span class="toc-text">埃氏筛法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B"><span class="toc-text">线性筛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0"><span class="toc-text">约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0"><span class="toc-text">莫比乌斯函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E5%BC%8F"><span class="toc-text">同余式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%EF%BC%88%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%EF%BC%89"><span class="toc-text">乘法逆元（费马小定理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E7%B3%BB"><span class="toc-text">剩余系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-text">欧拉定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-text">扩展欧拉定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86"><span class="toc-text">威尔逊定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86"><span class="toc-text">裴蜀定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E5%AE%9A%E7%90%86"><span class="toc-text">扩展欧几里得定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E6%96%B9%E7%A8%8B"><span class="toc-text">不定方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B"><span class="toc-text">同余方程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89"><span class="toc-text">乘法逆元（通用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88CRT%EF%BC%89"><span class="toc-text">中国剩余定理（CRT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88EXCRT%EF%BC%89"><span class="toc-text">扩展中国剩余定理（EXCRT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BSGS%E7%AE%97%E6%B3%95"><span class="toc-text">BSGS算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95BSGS%E7%AE%97%E6%B3%95"><span class="toc-text">扩展BSGS算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B"><span class="toc-text">线性方程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95"><span class="toc-text">高斯消元法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-text">组合数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E6%B3%95%EF%BC%88%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89"><span class="toc-text">递推法（杨辉三角）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-text">快速幂求组合数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%EF%BC%88Lucas%EF%BC%89"><span class="toc-text">卢卡斯定理（Lucas）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%AD%9B-%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0%EF%BC%88%E5%8D%95%E4%B8%AA%EF%BC%89"><span class="toc-text">线性筛+高精度求组合数（单个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E6%B3%95-%E9%AB%98%E7%B2%BE%E5%BA%A6%EF%BC%88%E5%8D%95%E4%B8%AA%EF%BC%89"><span class="toc-text">递推法+高精度（单个）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89"><span class="toc-text">组合数命名空间（快速幂）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E6%9D%BF%E6%B3%95"><span class="toc-text">隔板法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%EF%BC%88Catalan%EF%BC%89"><span class="toc-text">卡特兰数（Catalan）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="toc-text">容斥原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6"><span class="toc-text">集合的并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%A4"><span class="toc-text">集合的交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97"><span class="toc-text">整除分块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%8F%98%E9%87%8F%E6%95%B4%E6%95%B0%E5%88%86%E5%9D%97"><span class="toc-text">单变量整数分块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%8F%98%E9%87%8F%E6%95%B4%E6%95%B0%E5%88%86%E5%9D%97"><span class="toc-text">双变量整数分块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-text">普通生成函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-text">指数生成函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF"><span class="toc-text">狄利克雷卷积</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C%E5%BC%8F%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-text">和式的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%BC%8F%E7%9A%84%E5%8F%98%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-text">和式的变换规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%BC%8F%E7%9A%84%E5%8F%98%E6%8D%A2%E6%8A%80%E6%9C%AF"><span class="toc-text">和式的变换技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C%E5%BC%8F%E7%9A%84%E5%8F%98%E6%8D%A2%E6%8A%80%E5%B7%A7"><span class="toc-text">和式的变换技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94"><span class="toc-text">莫比乌斯反演</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%9C%E6%95%99%E7%AD%9B"><span class="toc-text">杜教筛</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-text">优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E6%8E%A8%E5%BC%8F%E8%AF%81%E6%98%8E"><span class="toc-text">递推式证明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%80%E5%B7%A7"><span class="toc-text">技巧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-s-n-sum-limits-n-i-1-varphi-i"><span class="toc-text">求 $s(n)&#x3D;\sum\limits^n_{i&#x3D;1}\varphi(i)$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82-s-n-sum-limits-n-i-1-mu-i"><span class="toc-text">求 $s(n)&#x3D;\sum\limits^n_{i&#x3D;1}\mu(i)$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">命名空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2-FFT"><span class="toc-text">快速傅里叶变换(FFT)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0"><span class="toc-text">复数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E5%9C%86-%E5%8D%95%E4%BD%8D%E6%A0%B9"><span class="toc-text">单位圆&#x2F;单位根</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FFT%E5%9F%BA%E7%A1%80"><span class="toc-text">FFT基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E7%B3%BB%E6%95%B0%E6%B1%82%E7%82%B9%E5%80%BC%EF%BC%88%E6%AD%A3%E5%8F%98%E6%8D%A2%EF%BC%89"><span class="toc-text">由系数求点值（正变换）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Untitled"><img alt="Untitled" src="/img/default.png"></a><div class="content"><a class="title" href="/2024/06/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B3%95%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/" title="Untitled">Untitled</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%B8%80-Linux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/" title="操作系统 实验一 Linux 内核编译"><img alt="操作系统 实验一 Linux 内核编译" src="/img/default.png"></a><div class="content"><a class="title" href="/2024/06/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E9%AA%8C%E4%B8%80-Linux-%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/" title="操作系统 实验一 Linux 内核编译">操作系统 实验一 Linux 内核编译</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/12/v2ray/" title="v2ray"><img alt="v2ray" src="/img/default.png"></a><div class="content"><a class="title" href="/2024/05/12/v2ray/" title="v2ray">v2ray</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/21/%E6%8B%AF%E6%95%91Pika-%E9%A2%98%E8%A7%A3/" title="拯救 Pika -题解"><img alt="拯救 Pika -题解" src="/img/default.png"></a><div class="content"><a class="title" href="/2024/04/21/%E6%8B%AF%E6%95%91Pika-%E9%A2%98%E8%A7%A3/" title="拯救 Pika -题解">拯救 Pika -题解</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/21/%E6%8B%AF%E6%95%91Pika%EF%BC%88middle%20version%EF%BC%89/" title="拯救 Pika （middle version）"><img alt="拯救 Pika （middle version）" src="/img/default.png"></a><div class="content"><a class="title" href="/2024/04/21/%E6%8B%AF%E6%95%91Pika%EF%BC%88middle%20version%EF%BC%89/" title="拯救 Pika （middle version）">拯救 Pika （middle version）</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>Lumosion</span></div><div class="footer-bar-description">来自Lumosion's Blog - 的文章</div><a class="footer-bar-link" href="/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2024 By&nbsp;<a class="footer-bar-link" href="/">Lumosion</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/valor-x/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/js/utils.js?v=1.8.12"></script><script src="/js/main.js?v=1.8.12"></script><script src="/js/third_party/waterfall.min.js?v=1.8.12"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.8.12"></script><script>dark()
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js"><script>(() => {
    document.querySelectorAll('#article-container span.katex-display').forEach(item => {
        utils.wrap(item, 'div', {class: 'katex-wrap'})
    })
})();
</script></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div class="js-pjax"></div></div><!-- newest comment--><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    is_rm && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><!-- music--></body></html><script>const posts=["2024/06/23/操作系统-实验二-内核编译法添加系统调用/","2024/06/23/操作系统-实验一-Linux-内核编译/","2024/05/12/v2ray/","2024/04/21/拯救Pika-题解/","2024/04/21/拯救Pika（middle version）/","2024/04/21/次元LAB - 题目及题解/","2024/04/21/板子/","2024/04/21/图论plus/","2024/04/21/树论/","2024/04/21/5 数论/","2024/04/21/jiangly板子/","2024/04/21/0 基础算法/","2024/04/21/1 搜索-图论/","2024/04/21/hello-world/"];function toRandomPost(){ pjax.loadUrl('/'+posts[Math.floor(Math.random()*posts.length)]); }</script>